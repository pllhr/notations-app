{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/ANALISE%20DE%20DADOS/notations/app/actions.ts"],"sourcesContent":["'use server';\n\nimport pool from '../lib/db';\nimport { Note } from '../types';\nimport { z } from 'zod';\nimport bcrypt from 'bcryptjs';\nimport { signIn } from '../auth';\nimport { AuthError } from 'next-auth';\n\n// --- Zod Schemas ---\nconst UserRegistrationSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(6),\n  role: z.enum(['USER', 'ADMIN']).optional(),\n});\n\nconst UserProfileSchema = z.object({\n  name: z.string().min(1).max(100),\n  image: z.string().optional(), // Allow empty string or null\n});\n\nconst NoteBlockSchema = z.object({\n  id: z.string(),\n  type: z.enum(['paragraph', 'heading', 'todo', 'bullet', 'blockquote', 'code', 'image']),\n  content: z.string(),\n  checked: z.boolean().optional(),\n});\n\nconst NoteSchema = z.object({\n  id: z.string(),\n  title: z.string(),\n  blocks: z.array(NoteBlockSchema),\n  position: z.object({ x: z.number(), y: z.number() }),\n  connections: z.array(z.string()),\n  tags: z.array(z.string()).optional(),\n  createdAt: z.number(),\n  color: z.string().optional(),\n});\n\n// --- Helper Functions ---\n\nasync function withRetry<T>(fn: () => Promise<T>, retries = 3, delay = 1000): Promise<T> {\n  try {\n    return await fn();\n  } catch (error) {\n    if (retries <= 0) throw error;\n    await new Promise(resolve => setTimeout(resolve, delay));\n    return withRetry(fn, retries - 1, delay * 2);\n  }\n}\n\nasync function ensureTable() {\n  try {\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS notes (\n        id TEXT PRIMARY KEY,\n        title TEXT,\n        data JSONB NOT NULL\n      );\n    `);\n\n    // Create Users Table\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id TEXT PRIMARY KEY,\n        email TEXT UNIQUE NOT NULL,\n        password_hash TEXT NOT NULL,\n        role TEXT NOT NULL DEFAULT 'USER',\n        created_at BIGINT NOT NULL,\n        name TEXT,\n        image TEXT\n      );\n    `);\n\n    // Create Tags Table for global tag management\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS tags (\n        id TEXT PRIMARY KEY,\n        name TEXT UNIQUE NOT NULL,\n        color TEXT NOT NULL DEFAULT '#3b82f6',\n        created_at BIGINT NOT NULL\n      );\n    `);\n\n    // Add columns if they don't exist (migration)\n    try {\n      await pool.query(`ALTER TABLE users ADD COLUMN IF NOT EXISTS name TEXT;`);\n      await pool.query(`ALTER TABLE users ADD COLUMN IF NOT EXISTS image TEXT;`);\n    } catch (e) {\n      console.log(\"Columns might already exist\");\n    }\n\n  } catch (e) {\n    console.error(\"Failed to ensure tables exist:\", e);\n  }\n}\n\nasync function fixSchema() {\n  try {\n    await pool.query(`\n            ALTER TABLE notes ADD COLUMN IF NOT EXISTS data JSONB;\n        `);\n  } catch (e) {\n    console.error(\"Failed to fix schema:\", e);\n  }\n}\n\n// --- Actions ---\n\nexport async function updateUserProfile(name: string, image: string) {\n  const validation = UserProfileSchema.safeParse({ name, image });\n  if (!validation.success) {\n    return { error: 'Invalid profile data.' };\n  }\n\n  try {\n    const session = await import('../auth').then(mod => mod.auth());\n    if (!session?.user?.email) return { error: 'Not authenticated' };\n\n    await pool.query(\n      'UPDATE users SET name = $1, image = $2 WHERE email = $3',\n      [name, image, session.user.email]\n    );\n    return { success: true };\n  } catch (error: any) {\n    if (error.code === '42703') { // Undefined column\n      await ensureTable();\n      try {\n        const session = await import('../auth').then(mod => mod.auth());\n        if (!session?.user?.email) return { error: 'Not authenticated' };\n\n        await pool.query(\n          'UPDATE users SET name = $1, image = $2 WHERE email = $3',\n          [name, image, session.user.email]\n        );\n        return { success: true };\n      } catch (retryError) {\n        console.error('Failed to update profile after migration:', retryError);\n        return { error: 'Failed to update profile' };\n      }\n    }\n    console.error('Failed to update profile:', error);\n    return { error: 'Failed to update profile' };\n  }\n}\n\nexport async function signOutAction() {\n  const { signOut } = await import('../auth');\n  await signOut({ redirectTo: '/login' });\n}\n\nexport async function getNotes(): Promise<Note[]> {\n  try {\n    const result = await pool.query('SELECT data FROM notes');\n    return result.rows\n      .map(row => row.data)\n      .filter((n): n is Note => n !== null && typeof n === 'object' && 'id' in n);\n  } catch (e: any) {\n    // Handle case where table might not exist yet\n    if (e.code === '42P01') {\n      await ensureTable();\n      return [];\n    }\n    // Handle case where column might not exist (schema mismatch)\n    if (e.code === '42703') {\n      await fixSchema();\n      // Retry fetch\n      try {\n        const retryResult = await pool.query('SELECT data FROM notes');\n        return retryResult.rows\n          .map(row => row.data)\n          .filter((n): n is Note => n !== null && typeof n === 'object' && 'id' in n);\n      } catch (retryError) {\n        console.error(\"Retry failed after schema fix:\", retryError);\n        return [];\n      }\n    }\n    console.error(\"Database Error:\", e);\n    return [];\n  }\n}\n\nexport async function saveNote(note: Note) {\n  // Validate Note Structure\n  const validation = NoteSchema.safeParse(note);\n  if (!validation.success) {\n    console.error(\"Invalid note data:\", validation.error);\n    throw new Error(\"Invalid note data\");\n  }\n\n  await withRetry(async () => {\n    try {\n      await pool.query(\n        `INSERT INTO notes (id, title, data) VALUES ($1, $2, $3) \n         ON CONFLICT (id) DO UPDATE SET title = $2, data = $3`,\n        [note.id, note.title || '', JSON.stringify(note)]\n      );\n    } catch (e: any) {\n      if (e.code === '42P01') {\n        await ensureTable();\n        // Retry once immediately after table creation\n        await pool.query(\n          `INSERT INTO notes (id, title, data) VALUES ($1, $2, $3) \n               ON CONFLICT (id) DO UPDATE SET title = $2, data = $3`,\n          [note.id, note.title || '', JSON.stringify(note)]\n        );\n      } else if (e.code === '42703') {\n        await fixSchema();\n        // Retry once immediately after schema fix\n        await pool.query(\n          `INSERT INTO notes (id, title, data) VALUES ($1, $2, $3) \n               ON CONFLICT (id) DO UPDATE SET title = $2, data = $3`,\n          [note.id, note.title || '', JSON.stringify(note)]\n        );\n      } else {\n        throw e;\n      }\n    }\n  });\n}\n\nexport async function deleteNoteAction(id: string) {\n  if (!id || typeof id !== 'string') return; // Basic validation\n  try {\n    await withRetry(async () => await pool.query('DELETE FROM notes WHERE id = $1', [id]));\n  } catch (e) {\n    console.error(\"Delete Error:\", e);\n  }\n}\n\nexport async function syncNotes(notes: Note[]) {\n  const validation = z.array(NoteSchema).safeParse(notes);\n  if (!validation.success) {\n    console.error(\"Invalid notes data for sync\");\n    return;\n  }\n\n  // Process in chunks or sequentially to avoid overwhelming the DB, but with retry per note\n  for (const note of notes) {\n    await saveNote(note);\n  }\n}\n\nexport async function registerUser(formData: FormData) {\n  const rawData = {\n    email: formData.get('email'),\n    password: formData.get('password'),\n    role: formData.get('role') || 'USER',\n  };\n\n  const validation = UserRegistrationSchema.safeParse(rawData);\n\n  if (!validation.success) {\n    return { error: 'Invalid email or password (min 6 chars).' };\n  }\n\n  const { email, password, role } = validation.data;\n\n  // Ensure table exists before registering\n  await ensureTable();\n\n  const hashedPassword = await bcrypt.hash(password, 10);\n  const id = crypto.randomUUID();\n\n  try {\n    await pool.query(\n      `INSERT INTO users (id, email, password_hash, role, created_at) VALUES ($1, $2, $3, $4, $5)`,\n      [id, email, hashedPassword, role, Date.now()]\n    );\n    return { success: true };\n  } catch (error: any) {\n    if (error.code === '23505') { // Unique violation\n      return { error: 'User already exists.' };\n    }\n    console.error('Registration error:', error);\n    return { error: 'Failed to register user.' };\n  }\n}\n\nexport async function authenticate(prevState: string | undefined, formData: FormData) {\n  try {\n    await signIn('credentials', {\n      ...Object.fromEntries(formData),\n      redirectTo: '/',\n    });\n  } catch (error) {\n    if (error instanceof AuthError) {\n      switch (error.type) {\n        case 'CredentialsSignin':\n          return 'Invalid credentials.';\n        default:\n          return 'Something went wrong.';\n      }\n    }\n    throw error;\n  }\n}\n\n// --- Tag Management Actions ---\n\nimport { Tag } from '../types';\n\nconst TagSchema = z.object({\n  id: z.string(),\n  name: z.string().min(1).max(50),\n  color: z.string().regex(/^#[0-9a-fA-F]{6}$/),\n  createdAt: z.number(),\n});\n\nexport async function getTags(): Promise<Tag[]> {\n  try {\n    await ensureTable();\n    const result = await pool.query('SELECT id, name, color, created_at FROM tags ORDER BY name');\n    return result.rows.map(row => ({\n      id: row.id,\n      name: row.name,\n      color: row.color,\n      createdAt: Number(row.created_at),\n    }));\n  } catch (e: any) {\n    if (e.code === '42P01') {\n      await ensureTable();\n      return [];\n    }\n    console.error(\"Failed to get tags:\", e);\n    return [];\n  }\n}\n\nexport async function createTag(name: string, color: string): Promise<{ success?: boolean; error?: string; tag?: Tag }> {\n  const id = crypto.randomUUID();\n  const createdAt = Date.now();\n\n  const validation = TagSchema.safeParse({ id, name: name.trim().toLowerCase(), color, createdAt });\n  if (!validation.success) {\n    return { error: 'Invalid tag data' };\n  }\n\n  try {\n    await ensureTable();\n    await pool.query(\n      'INSERT INTO tags (id, name, color, created_at) VALUES ($1, $2, $3, $4)',\n      [id, name.trim().toLowerCase(), color, createdAt]\n    );\n    return { success: true, tag: { id, name: name.trim().toLowerCase(), color, createdAt } };\n  } catch (e: any) {\n    if (e.code === '23505') {\n      return { error: 'Tag already exists' };\n    }\n    console.error(\"Failed to create tag:\", e);\n    return { error: 'Failed to create tag' };\n  }\n}\n\nexport async function updateTag(id: string, name: string, color: string): Promise<{ success?: boolean; error?: string }> {\n  if (!id || !name.trim()) {\n    return { error: 'Invalid tag data' };\n  }\n\n  try {\n    await pool.query(\n      'UPDATE tags SET name = $1, color = $2 WHERE id = $3',\n      [name.trim().toLowerCase(), color, id]\n    );\n    return { success: true };\n  } catch (e: any) {\n    if (e.code === '23505') {\n      return { error: 'Tag name already exists' };\n    }\n    console.error(\"Failed to update tag:\", e);\n    return { error: 'Failed to update tag' };\n  }\n}\n\nexport async function deleteTag(id: string, tagName: string): Promise<{ success?: boolean; error?: string }> {\n  if (!id) {\n    return { error: 'Invalid tag ID' };\n  }\n\n  try {\n    // Delete the tag from the tags table\n    await pool.query('DELETE FROM tags WHERE id = $1', [id]);\n\n    // Remove this tag from all notes that use it\n    const notesResult = await pool.query('SELECT id, data FROM notes');\n    for (const row of notesResult.rows) {\n      const note = row.data as Note;\n      if (note.tags && note.tags.includes(tagName)) {\n        const updatedTags = note.tags.filter(t => t !== tagName);\n        const updatedNote = { ...note, tags: updatedTags };\n        await pool.query(\n          'UPDATE notes SET data = $1 WHERE id = $2',\n          [JSON.stringify(updatedNote), note.id]\n        );\n      }\n    }\n\n    return { success: true };\n  } catch (e) {\n    console.error(\"Failed to delete tag:\", e);\n    return { error: 'Failed to delete tag' };\n  }\n}"],"names":[],"mappings":";;;;;;;IAqTsB,UAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///D:/ANALISE%20DE%20DADOS/notations/app/actions.ts"],"sourcesContent":["'use server';\n\nimport pool from '../lib/db';\nimport { Note } from '../types';\nimport { z } from 'zod';\nimport bcrypt from 'bcryptjs';\nimport { signIn } from '../auth';\nimport { AuthError } from 'next-auth';\n\n// --- Zod Schemas ---\nconst UserRegistrationSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(6),\n  role: z.enum(['USER', 'ADMIN']).optional(),\n});\n\nconst UserProfileSchema = z.object({\n  name: z.string().min(1).max(100),\n  image: z.string().optional(), // Allow empty string or null\n});\n\nconst NoteBlockSchema = z.object({\n  id: z.string(),\n  type: z.enum(['paragraph', 'heading', 'todo', 'bullet', 'blockquote', 'code', 'image']),\n  content: z.string(),\n  checked: z.boolean().optional(),\n});\n\nconst NoteSchema = z.object({\n  id: z.string(),\n  title: z.string(),\n  blocks: z.array(NoteBlockSchema),\n  position: z.object({ x: z.number(), y: z.number() }),\n  connections: z.array(z.string()),\n  tags: z.array(z.string()).optional(),\n  createdAt: z.number(),\n  color: z.string().optional(),\n});\n\n// --- Helper Functions ---\n\nasync function withRetry<T>(fn: () => Promise<T>, retries = 3, delay = 1000): Promise<T> {\n  try {\n    return await fn();\n  } catch (error) {\n    if (retries <= 0) throw error;\n    await new Promise(resolve => setTimeout(resolve, delay));\n    return withRetry(fn, retries - 1, delay * 2);\n  }\n}\n\nasync function ensureTable() {\n  try {\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS notes (\n        id TEXT PRIMARY KEY,\n        title TEXT,\n        data JSONB NOT NULL\n      );\n    `);\n\n    // Create Users Table\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id TEXT PRIMARY KEY,\n        email TEXT UNIQUE NOT NULL,\n        password_hash TEXT NOT NULL,\n        role TEXT NOT NULL DEFAULT 'USER',\n        created_at BIGINT NOT NULL,\n        name TEXT,\n        image TEXT\n      );\n    `);\n\n    // Create Tags Table for global tag management\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS tags (\n        id TEXT PRIMARY KEY,\n        name TEXT UNIQUE NOT NULL,\n        color TEXT NOT NULL DEFAULT '#3b82f6',\n        created_at BIGINT NOT NULL\n      );\n    `);\n\n    // Add columns if they don't exist (migration)\n    try {\n      await pool.query(`ALTER TABLE users ADD COLUMN IF NOT EXISTS name TEXT;`);\n      await pool.query(`ALTER TABLE users ADD COLUMN IF NOT EXISTS image TEXT;`);\n    } catch (e) {\n      console.log(\"Columns might already exist\");\n    }\n\n  } catch (e) {\n    console.error(\"Failed to ensure tables exist:\", e);\n  }\n}\n\nasync function fixSchema() {\n  try {\n    await pool.query(`\n            ALTER TABLE notes ADD COLUMN IF NOT EXISTS data JSONB;\n        `);\n  } catch (e) {\n    console.error(\"Failed to fix schema:\", e);\n  }\n}\n\n// --- Actions ---\n\nexport async function updateUserProfile(name: string, image: string) {\n  const validation = UserProfileSchema.safeParse({ name, image });\n  if (!validation.success) {\n    return { error: 'Invalid profile data.' };\n  }\n\n  try {\n    const session = await import('../auth').then(mod => mod.auth());\n    if (!session?.user?.email) return { error: 'Not authenticated' };\n\n    await pool.query(\n      'UPDATE users SET name = $1, image = $2 WHERE email = $3',\n      [name, image, session.user.email]\n    );\n    return { success: true };\n  } catch (error: any) {\n    if (error.code === '42703') { // Undefined column\n      await ensureTable();\n      try {\n        const session = await import('../auth').then(mod => mod.auth());\n        if (!session?.user?.email) return { error: 'Not authenticated' };\n\n        await pool.query(\n          'UPDATE users SET name = $1, image = $2 WHERE email = $3',\n          [name, image, session.user.email]\n        );\n        return { success: true };\n      } catch (retryError) {\n        console.error('Failed to update profile after migration:', retryError);\n        return { error: 'Failed to update profile' };\n      }\n    }\n    console.error('Failed to update profile:', error);\n    return { error: 'Failed to update profile' };\n  }\n}\n\nexport async function signOutAction() {\n  const { signOut } = await import('../auth');\n  await signOut({ redirectTo: '/login' });\n}\n\nexport async function getNotes(): Promise<Note[]> {\n  try {\n    const result = await pool.query('SELECT data FROM notes');\n    return result.rows\n      .map(row => row.data)\n      .filter((n): n is Note => n !== null && typeof n === 'object' && 'id' in n);\n  } catch (e: any) {\n    // Handle case where table might not exist yet\n    if (e.code === '42P01') {\n      await ensureTable();\n      return [];\n    }\n    // Handle case where column might not exist (schema mismatch)\n    if (e.code === '42703') {\n      await fixSchema();\n      // Retry fetch\n      try {\n        const retryResult = await pool.query('SELECT data FROM notes');\n        return retryResult.rows\n          .map(row => row.data)\n          .filter((n): n is Note => n !== null && typeof n === 'object' && 'id' in n);\n      } catch (retryError) {\n        console.error(\"Retry failed after schema fix:\", retryError);\n        return [];\n      }\n    }\n    console.error(\"Database Error:\", e);\n    return [];\n  }\n}\n\nexport async function saveNote(note: Note) {\n  // Validate Note Structure\n  const validation = NoteSchema.safeParse(note);\n  if (!validation.success) {\n    console.error(\"Invalid note data:\", validation.error);\n    throw new Error(\"Invalid note data\");\n  }\n\n  await withRetry(async () => {\n    try {\n      await pool.query(\n        `INSERT INTO notes (id, title, data) VALUES ($1, $2, $3) \n         ON CONFLICT (id) DO UPDATE SET title = $2, data = $3`,\n        [note.id, note.title || '', JSON.stringify(note)]\n      );\n    } catch (e: any) {\n      if (e.code === '42P01') {\n        await ensureTable();\n        // Retry once immediately after table creation\n        await pool.query(\n          `INSERT INTO notes (id, title, data) VALUES ($1, $2, $3) \n               ON CONFLICT (id) DO UPDATE SET title = $2, data = $3`,\n          [note.id, note.title || '', JSON.stringify(note)]\n        );\n      } else if (e.code === '42703') {\n        await fixSchema();\n        // Retry once immediately after schema fix\n        await pool.query(\n          `INSERT INTO notes (id, title, data) VALUES ($1, $2, $3) \n               ON CONFLICT (id) DO UPDATE SET title = $2, data = $3`,\n          [note.id, note.title || '', JSON.stringify(note)]\n        );\n      } else {\n        throw e;\n      }\n    }\n  });\n}\n\nexport async function deleteNoteAction(id: string) {\n  if (!id || typeof id !== 'string') return; // Basic validation\n  try {\n    await withRetry(async () => await pool.query('DELETE FROM notes WHERE id = $1', [id]));\n  } catch (e) {\n    console.error(\"Delete Error:\", e);\n  }\n}\n\nexport async function syncNotes(notes: Note[]) {\n  const validation = z.array(NoteSchema).safeParse(notes);\n  if (!validation.success) {\n    console.error(\"Invalid notes data for sync\");\n    return;\n  }\n\n  // Process in chunks or sequentially to avoid overwhelming the DB, but with retry per note\n  for (const note of notes) {\n    await saveNote(note);\n  }\n}\n\nexport async function registerUser(formData: FormData) {\n  const rawData = {\n    email: formData.get('email'),\n    password: formData.get('password'),\n    role: formData.get('role') || 'USER',\n  };\n\n  const validation = UserRegistrationSchema.safeParse(rawData);\n\n  if (!validation.success) {\n    return { error: 'Invalid email or password (min 6 chars).' };\n  }\n\n  const { email, password, role } = validation.data;\n\n  // Ensure table exists before registering\n  await ensureTable();\n\n  const hashedPassword = await bcrypt.hash(password, 10);\n  const id = crypto.randomUUID();\n\n  try {\n    await pool.query(\n      `INSERT INTO users (id, email, password_hash, role, created_at) VALUES ($1, $2, $3, $4, $5)`,\n      [id, email, hashedPassword, role, Date.now()]\n    );\n    return { success: true };\n  } catch (error: any) {\n    if (error.code === '23505') { // Unique violation\n      return { error: 'User already exists.' };\n    }\n    console.error('Registration error:', error);\n    return { error: 'Failed to register user.' };\n  }\n}\n\nexport async function authenticate(prevState: string | undefined, formData: FormData) {\n  try {\n    await signIn('credentials', {\n      ...Object.fromEntries(formData),\n      redirectTo: '/',\n    });\n  } catch (error) {\n    if (error instanceof AuthError) {\n      switch (error.type) {\n        case 'CredentialsSignin':\n          return 'Invalid credentials.';\n        default:\n          return 'Something went wrong.';\n      }\n    }\n    throw error;\n  }\n}\n\n// --- Tag Management Actions ---\n\nimport { Tag } from '../types';\n\nconst TagSchema = z.object({\n  id: z.string(),\n  name: z.string().min(1).max(50),\n  color: z.string().regex(/^#[0-9a-fA-F]{6}$/),\n  createdAt: z.number(),\n});\n\nexport async function getTags(): Promise<Tag[]> {\n  try {\n    await ensureTable();\n    const result = await pool.query('SELECT id, name, color, created_at FROM tags ORDER BY name');\n    return result.rows.map(row => ({\n      id: row.id,\n      name: row.name,\n      color: row.color,\n      createdAt: Number(row.created_at),\n    }));\n  } catch (e: any) {\n    if (e.code === '42P01') {\n      await ensureTable();\n      return [];\n    }\n    console.error(\"Failed to get tags:\", e);\n    return [];\n  }\n}\n\nexport async function createTag(name: string, color: string): Promise<{ success?: boolean; error?: string; tag?: Tag }> {\n  const id = crypto.randomUUID();\n  const createdAt = Date.now();\n\n  const validation = TagSchema.safeParse({ id, name: name.trim().toLowerCase(), color, createdAt });\n  if (!validation.success) {\n    return { error: 'Invalid tag data' };\n  }\n\n  try {\n    await ensureTable();\n    await pool.query(\n      'INSERT INTO tags (id, name, color, created_at) VALUES ($1, $2, $3, $4)',\n      [id, name.trim().toLowerCase(), color, createdAt]\n    );\n    return { success: true, tag: { id, name: name.trim().toLowerCase(), color, createdAt } };\n  } catch (e: any) {\n    if (e.code === '23505') {\n      return { error: 'Tag already exists' };\n    }\n    console.error(\"Failed to create tag:\", e);\n    return { error: 'Failed to create tag' };\n  }\n}\n\nexport async function updateTag(id: string, name: string, color: string): Promise<{ success?: boolean; error?: string }> {\n  if (!id || !name.trim()) {\n    return { error: 'Invalid tag data' };\n  }\n\n  try {\n    await pool.query(\n      'UPDATE tags SET name = $1, color = $2 WHERE id = $3',\n      [name.trim().toLowerCase(), color, id]\n    );\n    return { success: true };\n  } catch (e: any) {\n    if (e.code === '23505') {\n      return { error: 'Tag name already exists' };\n    }\n    console.error(\"Failed to update tag:\", e);\n    return { error: 'Failed to update tag' };\n  }\n}\n\nexport async function deleteTag(id: string, tagName: string): Promise<{ success?: boolean; error?: string }> {\n  if (!id) {\n    return { error: 'Invalid tag ID' };\n  }\n\n  try {\n    // Delete the tag from the tags table\n    await pool.query('DELETE FROM tags WHERE id = $1', [id]);\n\n    // Remove this tag from all notes that use it\n    const notesResult = await pool.query('SELECT id, data FROM notes');\n    for (const row of notesResult.rows) {\n      const note = row.data as Note;\n      if (note.tags && note.tags.includes(tagName)) {\n        const updatedTags = note.tags.filter(t => t !== tagName);\n        const updatedNote = { ...note, tags: updatedTags };\n        await pool.query(\n          'UPDATE notes SET data = $1 WHERE id = $2',\n          [JSON.stringify(updatedNote), note.id]\n        );\n      }\n    }\n\n    return { success: true };\n  } catch (e) {\n    console.error(\"Failed to delete tag:\", e);\n    return { error: 'Failed to delete tag' };\n  }\n}"],"names":[],"mappings":";;;;;;;IAyUsB,YAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///D:/ANALISE%20DE%20DADOS/notations/app/actions.ts"],"sourcesContent":["'use server';\n\nimport pool from '../lib/db';\nimport { Note } from '../types';\nimport { z } from 'zod';\nimport bcrypt from 'bcryptjs';\nimport { signIn } from '../auth';\nimport { AuthError } from 'next-auth';\n\n// --- Zod Schemas ---\nconst UserRegistrationSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(6),\n  role: z.enum(['USER', 'ADMIN']).optional(),\n});\n\nconst UserProfileSchema = z.object({\n  name: z.string().min(1).max(100),\n  image: z.string().optional(), // Allow empty string or null\n});\n\nconst NoteBlockSchema = z.object({\n  id: z.string(),\n  type: z.enum(['paragraph', 'heading', 'todo', 'bullet', 'blockquote', 'code', 'image']),\n  content: z.string(),\n  checked: z.boolean().optional(),\n});\n\nconst NoteSchema = z.object({\n  id: z.string(),\n  title: z.string(),\n  blocks: z.array(NoteBlockSchema),\n  position: z.object({ x: z.number(), y: z.number() }),\n  connections: z.array(z.string()),\n  tags: z.array(z.string()).optional(),\n  createdAt: z.number(),\n  color: z.string().optional(),\n});\n\n// --- Helper Functions ---\n\nasync function withRetry<T>(fn: () => Promise<T>, retries = 3, delay = 1000): Promise<T> {\n  try {\n    return await fn();\n  } catch (error) {\n    if (retries <= 0) throw error;\n    await new Promise(resolve => setTimeout(resolve, delay));\n    return withRetry(fn, retries - 1, delay * 2);\n  }\n}\n\nasync function ensureTable() {\n  try {\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS notes (\n        id TEXT PRIMARY KEY,\n        title TEXT,\n        data JSONB NOT NULL\n      );\n    `);\n\n    // Create Users Table\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id TEXT PRIMARY KEY,\n        email TEXT UNIQUE NOT NULL,\n        password_hash TEXT NOT NULL,\n        role TEXT NOT NULL DEFAULT 'USER',\n        created_at BIGINT NOT NULL,\n        name TEXT,\n        image TEXT\n      );\n    `);\n\n    // Create Tags Table for global tag management\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS tags (\n        id TEXT PRIMARY KEY,\n        name TEXT UNIQUE NOT NULL,\n        color TEXT NOT NULL DEFAULT '#3b82f6',\n        created_at BIGINT NOT NULL\n      );\n    `);\n\n    // Add columns if they don't exist (migration)\n    try {\n      await pool.query(`ALTER TABLE users ADD COLUMN IF NOT EXISTS name TEXT;`);\n      await pool.query(`ALTER TABLE users ADD COLUMN IF NOT EXISTS image TEXT;`);\n    } catch (e) {\n      console.log(\"Columns might already exist\");\n    }\n\n  } catch (e) {\n    console.error(\"Failed to ensure tables exist:\", e);\n  }\n}\n\nasync function fixSchema() {\n  try {\n    await pool.query(`\n            ALTER TABLE notes ADD COLUMN IF NOT EXISTS data JSONB;\n        `);\n  } catch (e) {\n    console.error(\"Failed to fix schema:\", e);\n  }\n}\n\n// --- Actions ---\n\nexport async function updateUserProfile(name: string, image: string) {\n  const validation = UserProfileSchema.safeParse({ name, image });\n  if (!validation.success) {\n    return { error: 'Invalid profile data.' };\n  }\n\n  try {\n    const session = await import('../auth').then(mod => mod.auth());\n    if (!session?.user?.email) return { error: 'Not authenticated' };\n\n    await pool.query(\n      'UPDATE users SET name = $1, image = $2 WHERE email = $3',\n      [name, image, session.user.email]\n    );\n    return { success: true };\n  } catch (error: any) {\n    if (error.code === '42703') { // Undefined column\n      await ensureTable();\n      try {\n        const session = await import('../auth').then(mod => mod.auth());\n        if (!session?.user?.email) return { error: 'Not authenticated' };\n\n        await pool.query(\n          'UPDATE users SET name = $1, image = $2 WHERE email = $3',\n          [name, image, session.user.email]\n        );\n        return { success: true };\n      } catch (retryError) {\n        console.error('Failed to update profile after migration:', retryError);\n        return { error: 'Failed to update profile' };\n      }\n    }\n    console.error('Failed to update profile:', error);\n    return { error: 'Failed to update profile' };\n  }\n}\n\nexport async function signOutAction() {\n  const { signOut } = await import('../auth');\n  await signOut({ redirectTo: '/login' });\n}\n\nexport async function getNotes(): Promise<Note[]> {\n  try {\n    const result = await pool.query('SELECT data FROM notes');\n    return result.rows\n      .map(row => row.data)\n      .filter((n): n is Note => n !== null && typeof n === 'object' && 'id' in n);\n  } catch (e: any) {\n    // Handle case where table might not exist yet\n    if (e.code === '42P01') {\n      await ensureTable();\n      return [];\n    }\n    // Handle case where column might not exist (schema mismatch)\n    if (e.code === '42703') {\n      await fixSchema();\n      // Retry fetch\n      try {\n        const retryResult = await pool.query('SELECT data FROM notes');\n        return retryResult.rows\n          .map(row => row.data)\n          .filter((n): n is Note => n !== null && typeof n === 'object' && 'id' in n);\n      } catch (retryError) {\n        console.error(\"Retry failed after schema fix:\", retryError);\n        return [];\n      }\n    }\n    console.error(\"Database Error:\", e);\n    return [];\n  }\n}\n\nexport async function saveNote(note: Note) {\n  // Validate Note Structure\n  const validation = NoteSchema.safeParse(note);\n  if (!validation.success) {\n    console.error(\"Invalid note data:\", validation.error);\n    throw new Error(\"Invalid note data\");\n  }\n\n  await withRetry(async () => {\n    try {\n      await pool.query(\n        `INSERT INTO notes (id, title, data) VALUES ($1, $2, $3) \n         ON CONFLICT (id) DO UPDATE SET title = $2, data = $3`,\n        [note.id, note.title || '', JSON.stringify(note)]\n      );\n    } catch (e: any) {\n      if (e.code === '42P01') {\n        await ensureTable();\n        // Retry once immediately after table creation\n        await pool.query(\n          `INSERT INTO notes (id, title, data) VALUES ($1, $2, $3) \n               ON CONFLICT (id) DO UPDATE SET title = $2, data = $3`,\n          [note.id, note.title || '', JSON.stringify(note)]\n        );\n      } else if (e.code === '42703') {\n        await fixSchema();\n        // Retry once immediately after schema fix\n        await pool.query(\n          `INSERT INTO notes (id, title, data) VALUES ($1, $2, $3) \n               ON CONFLICT (id) DO UPDATE SET title = $2, data = $3`,\n          [note.id, note.title || '', JSON.stringify(note)]\n        );\n      } else {\n        throw e;\n      }\n    }\n  });\n}\n\nexport async function deleteNoteAction(id: string) {\n  if (!id || typeof id !== 'string') return; // Basic validation\n  try {\n    await withRetry(async () => await pool.query('DELETE FROM notes WHERE id = $1', [id]));\n  } catch (e) {\n    console.error(\"Delete Error:\", e);\n  }\n}\n\nexport async function syncNotes(notes: Note[]) {\n  const validation = z.array(NoteSchema).safeParse(notes);\n  if (!validation.success) {\n    console.error(\"Invalid notes data for sync\");\n    return;\n  }\n\n  // Process in chunks or sequentially to avoid overwhelming the DB, but with retry per note\n  for (const note of notes) {\n    await saveNote(note);\n  }\n}\n\nexport async function registerUser(formData: FormData) {\n  const rawData = {\n    email: formData.get('email'),\n    password: formData.get('password'),\n    role: formData.get('role') || 'USER',\n  };\n\n  const validation = UserRegistrationSchema.safeParse(rawData);\n\n  if (!validation.success) {\n    return { error: 'Invalid email or password (min 6 chars).' };\n  }\n\n  const { email, password, role } = validation.data;\n\n  // Ensure table exists before registering\n  await ensureTable();\n\n  const hashedPassword = await bcrypt.hash(password, 10);\n  const id = crypto.randomUUID();\n\n  try {\n    await pool.query(\n      `INSERT INTO users (id, email, password_hash, role, created_at) VALUES ($1, $2, $3, $4, $5)`,\n      [id, email, hashedPassword, role, Date.now()]\n    );\n    return { success: true };\n  } catch (error: any) {\n    if (error.code === '23505') { // Unique violation\n      return { error: 'User already exists.' };\n    }\n    console.error('Registration error:', error);\n    return { error: 'Failed to register user.' };\n  }\n}\n\nexport async function authenticate(prevState: string | undefined, formData: FormData) {\n  try {\n    await signIn('credentials', {\n      ...Object.fromEntries(formData),\n      redirectTo: '/',\n    });\n  } catch (error) {\n    if (error instanceof AuthError) {\n      switch (error.type) {\n        case 'CredentialsSignin':\n          return 'Invalid credentials.';\n        default:\n          return 'Something went wrong.';\n      }\n    }\n    throw error;\n  }\n}\n\n// --- Tag Management Actions ---\n\nimport { Tag } from '../types';\n\nconst TagSchema = z.object({\n  id: z.string(),\n  name: z.string().min(1).max(50),\n  color: z.string().regex(/^#[0-9a-fA-F]{6}$/),\n  createdAt: z.number(),\n});\n\nexport async function getTags(): Promise<Tag[]> {\n  try {\n    await ensureTable();\n    const result = await pool.query('SELECT id, name, color, created_at FROM tags ORDER BY name');\n    return result.rows.map(row => ({\n      id: row.id,\n      name: row.name,\n      color: row.color,\n      createdAt: Number(row.created_at),\n    }));\n  } catch (e: any) {\n    if (e.code === '42P01') {\n      await ensureTable();\n      return [];\n    }\n    console.error(\"Failed to get tags:\", e);\n    return [];\n  }\n}\n\nexport async function createTag(name: string, color: string): Promise<{ success?: boolean; error?: string; tag?: Tag }> {\n  const id = crypto.randomUUID();\n  const createdAt = Date.now();\n\n  const validation = TagSchema.safeParse({ id, name: name.trim().toLowerCase(), color, createdAt });\n  if (!validation.success) {\n    return { error: 'Invalid tag data' };\n  }\n\n  try {\n    await ensureTable();\n    await pool.query(\n      'INSERT INTO tags (id, name, color, created_at) VALUES ($1, $2, $3, $4)',\n      [id, name.trim().toLowerCase(), color, createdAt]\n    );\n    return { success: true, tag: { id, name: name.trim().toLowerCase(), color, createdAt } };\n  } catch (e: any) {\n    if (e.code === '23505') {\n      return { error: 'Tag already exists' };\n    }\n    console.error(\"Failed to create tag:\", e);\n    return { error: 'Failed to create tag' };\n  }\n}\n\nexport async function updateTag(id: string, name: string, color: string): Promise<{ success?: boolean; error?: string }> {\n  if (!id || !name.trim()) {\n    return { error: 'Invalid tag data' };\n  }\n\n  try {\n    await pool.query(\n      'UPDATE tags SET name = $1, color = $2 WHERE id = $3',\n      [name.trim().toLowerCase(), color, id]\n    );\n    return { success: true };\n  } catch (e: any) {\n    if (e.code === '23505') {\n      return { error: 'Tag name already exists' };\n    }\n    console.error(\"Failed to update tag:\", e);\n    return { error: 'Failed to update tag' };\n  }\n}\n\nexport async function deleteTag(id: string, tagName: string): Promise<{ success?: boolean; error?: string }> {\n  if (!id) {\n    return { error: 'Invalid tag ID' };\n  }\n\n  try {\n    // Delete the tag from the tags table\n    await pool.query('DELETE FROM tags WHERE id = $1', [id]);\n\n    // Remove this tag from all notes that use it\n    const notesResult = await pool.query('SELECT id, data FROM notes');\n    for (const row of notesResult.rows) {\n      const note = row.data as Note;\n      if (note.tags && note.tags.includes(tagName)) {\n        const updatedTags = note.tags.filter(t => t !== tagName);\n        const updatedNote = { ...note, tags: updatedTags };\n        await pool.query(\n          'UPDATE notes SET data = $1 WHERE id = $2',\n          [JSON.stringify(updatedNote), note.id]\n        );\n      }\n    }\n\n    return { success: true };\n  } catch (e) {\n    console.error(\"Failed to delete tag:\", e);\n    return { error: 'Failed to delete tag' };\n  }\n}"],"names":[],"mappings":";;;;;;;IAkWsB,YAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///D:/ANALISE%20DE%20DADOS/notations/app/actions.ts"],"sourcesContent":["'use server';\n\nimport pool from '../lib/db';\nimport { Note } from '../types';\nimport { z } from 'zod';\nimport bcrypt from 'bcryptjs';\nimport { signIn } from '../auth';\nimport { AuthError } from 'next-auth';\n\n// --- Zod Schemas ---\nconst UserRegistrationSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(6),\n  role: z.enum(['USER', 'ADMIN']).optional(),\n});\n\nconst UserProfileSchema = z.object({\n  name: z.string().min(1).max(100),\n  image: z.string().optional(), // Allow empty string or null\n});\n\nconst NoteBlockSchema = z.object({\n  id: z.string(),\n  type: z.enum(['paragraph', 'heading', 'todo', 'bullet', 'blockquote', 'code', 'image']),\n  content: z.string(),\n  checked: z.boolean().optional(),\n});\n\nconst NoteSchema = z.object({\n  id: z.string(),\n  title: z.string(),\n  blocks: z.array(NoteBlockSchema),\n  position: z.object({ x: z.number(), y: z.number() }),\n  connections: z.array(z.string()),\n  tags: z.array(z.string()).optional(),\n  createdAt: z.number(),\n  color: z.string().optional(),\n});\n\n// --- Helper Functions ---\n\nasync function withRetry<T>(fn: () => Promise<T>, retries = 3, delay = 1000): Promise<T> {\n  try {\n    return await fn();\n  } catch (error) {\n    if (retries <= 0) throw error;\n    await new Promise(resolve => setTimeout(resolve, delay));\n    return withRetry(fn, retries - 1, delay * 2);\n  }\n}\n\nasync function ensureTable() {\n  try {\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS notes (\n        id TEXT PRIMARY KEY,\n        title TEXT,\n        data JSONB NOT NULL\n      );\n    `);\n\n    // Create Users Table\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id TEXT PRIMARY KEY,\n        email TEXT UNIQUE NOT NULL,\n        password_hash TEXT NOT NULL,\n        role TEXT NOT NULL DEFAULT 'USER',\n        created_at BIGINT NOT NULL,\n        name TEXT,\n        image TEXT\n      );\n    `);\n\n    // Create Tags Table for global tag management\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS tags (\n        id TEXT PRIMARY KEY,\n        name TEXT UNIQUE NOT NULL,\n        color TEXT NOT NULL DEFAULT '#3b82f6',\n        created_at BIGINT NOT NULL\n      );\n    `);\n\n    // Add columns if they don't exist (migration)\n    try {\n      await pool.query(`ALTER TABLE users ADD COLUMN IF NOT EXISTS name TEXT;`);\n      await pool.query(`ALTER TABLE users ADD COLUMN IF NOT EXISTS image TEXT;`);\n    } catch (e) {\n      console.log(\"Columns might already exist\");\n    }\n\n  } catch (e) {\n    console.error(\"Failed to ensure tables exist:\", e);\n  }\n}\n\nasync function fixSchema() {\n  try {\n    await pool.query(`\n            ALTER TABLE notes ADD COLUMN IF NOT EXISTS data JSONB;\n        `);\n  } catch (e) {\n    console.error(\"Failed to fix schema:\", e);\n  }\n}\n\n// --- Actions ---\n\nexport async function updateUserProfile(name: string, image: string) {\n  const validation = UserProfileSchema.safeParse({ name, image });\n  if (!validation.success) {\n    return { error: 'Invalid profile data.' };\n  }\n\n  try {\n    const session = await import('../auth').then(mod => mod.auth());\n    if (!session?.user?.email) return { error: 'Not authenticated' };\n\n    await pool.query(\n      'UPDATE users SET name = $1, image = $2 WHERE email = $3',\n      [name, image, session.user.email]\n    );\n    return { success: true };\n  } catch (error: any) {\n    if (error.code === '42703') { // Undefined column\n      await ensureTable();\n      try {\n        const session = await import('../auth').then(mod => mod.auth());\n        if (!session?.user?.email) return { error: 'Not authenticated' };\n\n        await pool.query(\n          'UPDATE users SET name = $1, image = $2 WHERE email = $3',\n          [name, image, session.user.email]\n        );\n        return { success: true };\n      } catch (retryError) {\n        console.error('Failed to update profile after migration:', retryError);\n        return { error: 'Failed to update profile' };\n      }\n    }\n    console.error('Failed to update profile:', error);\n    return { error: 'Failed to update profile' };\n  }\n}\n\nexport async function signOutAction() {\n  const { signOut } = await import('../auth');\n  await signOut({ redirectTo: '/login' });\n}\n\nexport async function getNotes(): Promise<Note[]> {\n  try {\n    const result = await pool.query('SELECT data FROM notes');\n    return result.rows\n      .map(row => row.data)\n      .filter((n): n is Note => n !== null && typeof n === 'object' && 'id' in n);\n  } catch (e: any) {\n    // Handle case where table might not exist yet\n    if (e.code === '42P01') {\n      await ensureTable();\n      return [];\n    }\n    // Handle case where column might not exist (schema mismatch)\n    if (e.code === '42703') {\n      await fixSchema();\n      // Retry fetch\n      try {\n        const retryResult = await pool.query('SELECT data FROM notes');\n        return retryResult.rows\n          .map(row => row.data)\n          .filter((n): n is Note => n !== null && typeof n === 'object' && 'id' in n);\n      } catch (retryError) {\n        console.error(\"Retry failed after schema fix:\", retryError);\n        return [];\n      }\n    }\n    console.error(\"Database Error:\", e);\n    return [];\n  }\n}\n\nexport async function saveNote(note: Note) {\n  // Validate Note Structure\n  const validation = NoteSchema.safeParse(note);\n  if (!validation.success) {\n    console.error(\"Invalid note data:\", validation.error);\n    throw new Error(\"Invalid note data\");\n  }\n\n  await withRetry(async () => {\n    try {\n      await pool.query(\n        `INSERT INTO notes (id, title, data) VALUES ($1, $2, $3) \n         ON CONFLICT (id) DO UPDATE SET title = $2, data = $3`,\n        [note.id, note.title || '', JSON.stringify(note)]\n      );\n    } catch (e: any) {\n      if (e.code === '42P01') {\n        await ensureTable();\n        // Retry once immediately after table creation\n        await pool.query(\n          `INSERT INTO notes (id, title, data) VALUES ($1, $2, $3) \n               ON CONFLICT (id) DO UPDATE SET title = $2, data = $3`,\n          [note.id, note.title || '', JSON.stringify(note)]\n        );\n      } else if (e.code === '42703') {\n        await fixSchema();\n        // Retry once immediately after schema fix\n        await pool.query(\n          `INSERT INTO notes (id, title, data) VALUES ($1, $2, $3) \n               ON CONFLICT (id) DO UPDATE SET title = $2, data = $3`,\n          [note.id, note.title || '', JSON.stringify(note)]\n        );\n      } else {\n        throw e;\n      }\n    }\n  });\n}\n\nexport async function deleteNoteAction(id: string) {\n  if (!id || typeof id !== 'string') return; // Basic validation\n  try {\n    await withRetry(async () => await pool.query('DELETE FROM notes WHERE id = $1', [id]));\n  } catch (e) {\n    console.error(\"Delete Error:\", e);\n  }\n}\n\nexport async function syncNotes(notes: Note[]) {\n  const validation = z.array(NoteSchema).safeParse(notes);\n  if (!validation.success) {\n    console.error(\"Invalid notes data for sync\");\n    return;\n  }\n\n  // Process in chunks or sequentially to avoid overwhelming the DB, but with retry per note\n  for (const note of notes) {\n    await saveNote(note);\n  }\n}\n\nexport async function registerUser(formData: FormData) {\n  const rawData = {\n    email: formData.get('email'),\n    password: formData.get('password'),\n    role: formData.get('role') || 'USER',\n  };\n\n  const validation = UserRegistrationSchema.safeParse(rawData);\n\n  if (!validation.success) {\n    return { error: 'Invalid email or password (min 6 chars).' };\n  }\n\n  const { email, password, role } = validation.data;\n\n  // Ensure table exists before registering\n  await ensureTable();\n\n  const hashedPassword = await bcrypt.hash(password, 10);\n  const id = crypto.randomUUID();\n\n  try {\n    await pool.query(\n      `INSERT INTO users (id, email, password_hash, role, created_at) VALUES ($1, $2, $3, $4, $5)`,\n      [id, email, hashedPassword, role, Date.now()]\n    );\n    return { success: true };\n  } catch (error: any) {\n    if (error.code === '23505') { // Unique violation\n      return { error: 'User already exists.' };\n    }\n    console.error('Registration error:', error);\n    return { error: 'Failed to register user.' };\n  }\n}\n\nexport async function authenticate(prevState: string | undefined, formData: FormData) {\n  try {\n    await signIn('credentials', {\n      ...Object.fromEntries(formData),\n      redirectTo: '/',\n    });\n  } catch (error) {\n    if (error instanceof AuthError) {\n      switch (error.type) {\n        case 'CredentialsSignin':\n          return 'Invalid credentials.';\n        default:\n          return 'Something went wrong.';\n      }\n    }\n    throw error;\n  }\n}\n\n// --- Tag Management Actions ---\n\nimport { Tag } from '../types';\n\nconst TagSchema = z.object({\n  id: z.string(),\n  name: z.string().min(1).max(50),\n  color: z.string().regex(/^#[0-9a-fA-F]{6}$/),\n  createdAt: z.number(),\n});\n\nexport async function getTags(): Promise<Tag[]> {\n  try {\n    await ensureTable();\n    const result = await pool.query('SELECT id, name, color, created_at FROM tags ORDER BY name');\n    return result.rows.map(row => ({\n      id: row.id,\n      name: row.name,\n      color: row.color,\n      createdAt: Number(row.created_at),\n    }));\n  } catch (e: any) {\n    if (e.code === '42P01') {\n      await ensureTable();\n      return [];\n    }\n    console.error(\"Failed to get tags:\", e);\n    return [];\n  }\n}\n\nexport async function createTag(name: string, color: string): Promise<{ success?: boolean; error?: string; tag?: Tag }> {\n  const id = crypto.randomUUID();\n  const createdAt = Date.now();\n\n  const validation = TagSchema.safeParse({ id, name: name.trim().toLowerCase(), color, createdAt });\n  if (!validation.success) {\n    return { error: 'Invalid tag data' };\n  }\n\n  try {\n    await ensureTable();\n    await pool.query(\n      'INSERT INTO tags (id, name, color, created_at) VALUES ($1, $2, $3, $4)',\n      [id, name.trim().toLowerCase(), color, createdAt]\n    );\n    return { success: true, tag: { id, name: name.trim().toLowerCase(), color, createdAt } };\n  } catch (e: any) {\n    if (e.code === '23505') {\n      return { error: 'Tag already exists' };\n    }\n    console.error(\"Failed to create tag:\", e);\n    return { error: 'Failed to create tag' };\n  }\n}\n\nexport async function updateTag(id: string, name: string, color: string): Promise<{ success?: boolean; error?: string }> {\n  if (!id || !name.trim()) {\n    return { error: 'Invalid tag data' };\n  }\n\n  try {\n    await pool.query(\n      'UPDATE tags SET name = $1, color = $2 WHERE id = $3',\n      [name.trim().toLowerCase(), color, id]\n    );\n    return { success: true };\n  } catch (e: any) {\n    if (e.code === '23505') {\n      return { error: 'Tag name already exists' };\n    }\n    console.error(\"Failed to update tag:\", e);\n    return { error: 'Failed to update tag' };\n  }\n}\n\nexport async function deleteTag(id: string, tagName: string): Promise<{ success?: boolean; error?: string }> {\n  if (!id) {\n    return { error: 'Invalid tag ID' };\n  }\n\n  try {\n    // Delete the tag from the tags table\n    await pool.query('DELETE FROM tags WHERE id = $1', [id]);\n\n    // Remove this tag from all notes that use it\n    const notesResult = await pool.query('SELECT id, data FROM notes');\n    for (const row of notesResult.rows) {\n      const note = row.data as Note;\n      if (note.tags && note.tags.includes(tagName)) {\n        const updatedTags = note.tags.filter(t => t !== tagName);\n        const updatedNote = { ...note, tags: updatedTags };\n        await pool.query(\n          'UPDATE notes SET data = $1 WHERE id = $2',\n          [JSON.stringify(updatedNote), note.id]\n        );\n      }\n    }\n\n    return { success: true };\n  } catch (e) {\n    console.error(\"Failed to delete tag:\", e);\n    return { error: 'Failed to delete tag' };\n  }\n}"],"names":[],"mappings":";;;;;;;IAsXsB,YAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///D:/ANALISE%20DE%20DADOS/notations/app/admin/page.tsx"],"sourcesContent":["'use client';\r\n\r\nimport React, { useState, useEffect } from 'react';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\nimport { Tag as TagIcon, Plus, Trash2, Edit3, X, Check, ArrowLeft, Sparkles } from 'lucide-react';\r\nimport { Tag } from '../../types';\r\nimport { getTags, createTag, updateTag, deleteTag } from '../actions';\r\nimport Link from 'next/link';\r\n\r\nconst TAG_COLORS = [\r\n    { color: '#3b82f6', name: 'Blue' },\r\n    { color: '#10b981', name: 'Emerald' },\r\n    { color: '#f59e0b', name: 'Amber' },\r\n    { color: '#ef4444', name: 'Red' },\r\n    { color: '#8b5cf6', name: 'Purple' },\r\n    { color: '#ec4899', name: 'Pink' },\r\n    { color: '#06b6d4', name: 'Cyan' },\r\n    { color: '#f97316', name: 'Orange' },\r\n    { color: '#6366f1', name: 'Indigo' },\r\n    { color: '#84cc16', name: 'Lime' },\r\n];\r\n\r\nexport default function AdminPage() {\r\n    const [tags, setTags] = useState<Tag[]>([]);\r\n    const [isLoading, setIsLoading] = useState(true);\r\n    const [newTagName, setNewTagName] = useState('');\r\n    const [newTagColor, setNewTagColor] = useState('#3b82f6');\r\n    const [editingTag, setEditingTag] = useState<Tag | null>(null);\r\n    const [editName, setEditName] = useState('');\r\n    const [editColor, setEditColor] = useState('');\r\n    const [deleteConfirm, setDeleteConfirm] = useState<Tag | null>(null);\r\n    const [error, setError] = useState<string | null>(null);\r\n    const [showColorPicker, setShowColorPicker] = useState(false);\r\n    const [successMessage, setSuccessMessage] = useState<string | null>(null);\r\n\r\n    useEffect(() => {\r\n        loadTags();\r\n    }, []);\r\n\r\n    const loadTags = async () => {\r\n        setIsLoading(true);\r\n        const fetchedTags = await getTags();\r\n        setTags(fetchedTags);\r\n        setIsLoading(false);\r\n    };\r\n\r\n    const showSuccess = (message: string) => {\r\n        setSuccessMessage(message);\r\n        setTimeout(() => setSuccessMessage(null), 3000);\r\n    };\r\n\r\n    const handleCreateTag = async () => {\r\n        if (!newTagName.trim()) {\r\n            setError('Tag name is required');\r\n            return;\r\n        }\r\n\r\n        const result = await createTag(newTagName, newTagColor);\r\n        if (result.error) {\r\n            setError(result.error);\r\n        } else if (result.tag) {\r\n            setTags([...tags, result.tag]);\r\n            setNewTagName('');\r\n            setNewTagColor('#3b82f6');\r\n            setError(null);\r\n            showSuccess('Tag created successfully!');\r\n        }\r\n    };\r\n\r\n    const handleUpdateTag = async () => {\r\n        if (!editingTag || !editName.trim()) return;\r\n\r\n        const result = await updateTag(editingTag.id, editName, editColor);\r\n        if (result.error) {\r\n            setError(result.error);\r\n        } else {\r\n            setTags(tags.map(t => t.id === editingTag.id ? { ...t, name: editName.toLowerCase(), color: editColor } : t));\r\n            setEditingTag(null);\r\n            setError(null);\r\n            showSuccess('Tag updated successfully!');\r\n        }\r\n    };\r\n\r\n    const handleDeleteTag = async () => {\r\n        if (!deleteConfirm) return;\r\n\r\n        const result = await deleteTag(deleteConfirm.id, deleteConfirm.name);\r\n        if (result.error) {\r\n            setError(result.error);\r\n        } else {\r\n            setTags(tags.filter(t => t.id !== deleteConfirm.id));\r\n            setDeleteConfirm(null);\r\n            setError(null);\r\n            showSuccess('Tag deleted successfully!');\r\n        }\r\n    };\r\n\r\n    const startEdit = (tag: Tag) => {\r\n        setEditingTag(tag);\r\n        setEditName(tag.name);\r\n        setEditColor(tag.color);\r\n    };\r\n\r\n    return (\r\n        <div className=\"min-h-screen bg-[#0a0a0a]\">\r\n            {/* Animated Background */}\r\n            <div className=\"fixed inset-0 overflow-hidden pointer-events-none\">\r\n                <div className=\"absolute -top-40 -right-40 w-80 h-80 bg-purple-500/10 rounded-full blur-3xl animate-pulse\" />\r\n                <div className=\"absolute -bottom-40 -left-40 w-80 h-80 bg-blue-500/10 rounded-full blur-3xl animate-pulse\" style={{ animationDelay: '1s' }} />\r\n            </div>\r\n\r\n            <div className=\"relative max-w-4xl mx-auto px-6 py-12\">\r\n                {/* Header */}\r\n                <motion.div\r\n                    initial={{ opacity: 0, y: -20 }}\r\n                    animate={{ opacity: 1, y: 0 }}\r\n                    transition={{ duration: 0.5 }}\r\n                    className=\"flex items-center gap-4 mb-10\"\r\n                >\r\n                    <Link href=\"/\">\r\n                        <motion.div\r\n                            whileHover={{ scale: 1.1, x: -5 }}\r\n                            whileTap={{ scale: 0.9 }}\r\n                            className=\"p-3 bg-white/5 hover:bg-white/10 rounded-xl transition-colors border border-white/10\"\r\n                        >\r\n                            <ArrowLeft size={24} className=\"text-white\" />\r\n                        </motion.div>\r\n                    </Link>\r\n                    <div>\r\n                        <h1 className=\"text-4xl font-black text-white tracking-tight\">Tag Management</h1>\r\n                        <p className=\"text-gray-400 text-sm mt-1\">Create, edit, and manage your global tags</p>\r\n                    </div>\r\n                </motion.div>\r\n\r\n                {/* Success Message */}\r\n                <AnimatePresence>\r\n                    {successMessage && (\r\n                        <motion.div\r\n                            initial={{ opacity: 0, y: -20, scale: 0.95 }}\r\n                            animate={{ opacity: 1, y: 0, scale: 1 }}\r\n                            exit={{ opacity: 0, y: -20, scale: 0.95 }}\r\n                            className=\"mb-6 p-4 bg-emerald-500/20 border border-emerald-500/30 rounded-2xl text-emerald-400 flex items-center gap-3\"\r\n                        >\r\n                            <Sparkles size={20} />\r\n                            <span className=\"font-medium\">{successMessage}</span>\r\n                        </motion.div>\r\n                    )}\r\n                </AnimatePresence>\r\n\r\n                {/* Error Message */}\r\n                <AnimatePresence>\r\n                    {error && (\r\n                        <motion.div\r\n                            initial={{ opacity: 0, y: -20, scale: 0.95 }}\r\n                            animate={{ opacity: 1, y: 0, scale: 1 }}\r\n                            exit={{ opacity: 0, y: -20, scale: 0.95 }}\r\n                            className=\"mb-6 p-4 bg-red-500/20 border border-red-500/30 rounded-2xl text-red-400 flex items-center justify-between\"\r\n                        >\r\n                            <span className=\"font-medium\">{error}</span>\r\n                            <button onClick={() => setError(null)} className=\"hover:bg-red-500/20 p-1.5 rounded-lg transition-colors\">\r\n                                <X size={18} />\r\n                            </button>\r\n                        </motion.div>\r\n                    )}\r\n                </AnimatePresence>\r\n\r\n                {/* Create New Tag */}\r\n                <motion.div\r\n                    initial={{ opacity: 0, y: 20 }}\r\n                    animate={{ opacity: 1, y: 0 }}\r\n                    transition={{ duration: 0.5, delay: 0.1 }}\r\n                    className=\"bg-gradient-to-br from-white/[0.08] to-white/[0.02] backdrop-blur-xl rounded-3xl border border-white/10 p-8 mb-8 shadow-2xl overflow-visible relative z-20\"\r\n                >\r\n                    <h2 className=\"text-xl font-bold text-white mb-6 flex items-center gap-3\">\r\n                        <div className=\"p-2 bg-gradient-to-br from-blue-500 to-purple-500 rounded-xl\">\r\n                            <Plus size={20} className=\"text-white\" />\r\n                        </div>\r\n                        Create New Tag\r\n                    </h2>\r\n\r\n                    <div className=\"flex flex-col md:flex-row gap-4 items-start md:items-end\">\r\n                        {/* Tag Name Input */}\r\n                        <div className=\"flex-1 w-full\">\r\n                            <label className=\"block text-sm font-medium text-gray-400 mb-2\">Tag Name</label>\r\n                            <input\r\n                                type=\"text\"\r\n                                value={newTagName}\r\n                                onChange={(e) => setNewTagName(e.target.value)}\r\n                                onKeyDown={(e) => e.key === 'Enter' && handleCreateTag()}\r\n                                placeholder=\"Enter tag name...\"\r\n                                className=\"w-full px-5 py-4 bg-black/50 border border-white/10 rounded-2xl text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:border-blue-500/50 transition-all\"\r\n                            />\r\n                        </div>\r\n\r\n                        {/* Color Picker */}\r\n                        <div className=\"relative z-30\">\r\n                            <label className=\"block text-sm font-medium text-gray-400 mb-2\">Color</label>\r\n                            <motion.button\r\n                                whileHover={{ scale: 1.05 }}\r\n                                whileTap={{ scale: 0.95 }}\r\n                                onClick={() => setShowColorPicker(!showColorPicker)}\r\n                                className=\"w-16 h-14 rounded-2xl border-2 border-white/20 transition-all hover:border-white/40 shadow-lg relative overflow-hidden\"\r\n                                style={{ backgroundColor: newTagColor }}\r\n                            >\r\n                                <div className=\"absolute inset-0 bg-gradient-to-br from-white/20 to-transparent\" />\r\n                            </motion.button>\r\n\r\n                            <AnimatePresence>\r\n                                {showColorPicker && (\r\n                                    <>\r\n                                        <div className=\"fixed inset-0 z-[99]\" onClick={() => setShowColorPicker(false)} />\r\n                                        <motion.div\r\n                                            initial={{ opacity: 0, scale: 0.9, y: 10 }}\r\n                                            animate={{ opacity: 1, scale: 1, y: 0 }}\r\n                                            exit={{ opacity: 0, scale: 0.9, y: 10 }}\r\n                                            transition={{ type: 'spring', stiffness: 300, damping: 25 }}\r\n                                            className=\"absolute top-full mt-3 right-0 bg-neutral-900 border border-white/10 rounded-2xl p-4 shadow-2xl z-[100]\"\r\n                                            style={{ minWidth: '220px' }}\r\n                                        >\r\n                                            <p className=\"text-xs font-medium text-gray-400 mb-3\">Select a color</p>\r\n                                            <div className=\"grid grid-cols-5 gap-3\">\r\n                                                {TAG_COLORS.map(({ color, name }) => (\r\n                                                    <motion.button\r\n                                                        key={color}\r\n                                                        whileHover={{ scale: 1.15 }}\r\n                                                        whileTap={{ scale: 0.9 }}\r\n                                                        onClick={() => { setNewTagColor(color); setShowColorPicker(false); }}\r\n                                                        className={`w-9 h-9 rounded-xl transition-all relative ${newTagColor === color ? 'ring-2 ring-offset-2 ring-offset-neutral-900 ring-white' : 'hover:ring-2 hover:ring-white/30'}`}\r\n                                                        style={{ backgroundColor: color }}\r\n                                                        title={name}\r\n                                                    >\r\n                                                        {newTagColor === color && (\r\n                                                            <motion.div\r\n                                                                initial={{ scale: 0 }}\r\n                                                                animate={{ scale: 1 }}\r\n                                                                className=\"absolute inset-0 flex items-center justify-center\"\r\n                                                            >\r\n                                                                <Check size={16} className=\"text-white drop-shadow-lg\" />\r\n                                                            </motion.div>\r\n                                                        )}\r\n                                                    </motion.button>\r\n                                                ))}\r\n                                            </div>\r\n                                        </motion.div>\r\n                                    </>\r\n                                )}\r\n                            </AnimatePresence>\r\n                        </div>\r\n\r\n                        {/* Create Button */}\r\n                        <motion.button\r\n                            whileHover={{ scale: 1.02 }}\r\n                            whileTap={{ scale: 0.98 }}\r\n                            onClick={handleCreateTag}\r\n                            className=\"px-8 py-4 bg-gradient-to-r from-blue-500 to-purple-500 text-white font-bold rounded-2xl hover:shadow-lg hover:shadow-blue-500/25 transition-all flex items-center gap-2\"\r\n                        >\r\n                            <Plus size={20} />\r\n                            Create Tag\r\n                        </motion.button>\r\n                    </div>\r\n                </motion.div>\r\n\r\n                {/* Tags List */}\r\n                <motion.div\r\n                    initial={{ opacity: 0, y: 20 }}\r\n                    animate={{ opacity: 1, y: 0 }}\r\n                    transition={{ duration: 0.5, delay: 0.2 }}\r\n                    className=\"bg-gradient-to-br from-white/[0.08] to-white/[0.02] backdrop-blur-xl rounded-3xl border border-white/10 p-8 shadow-2xl\"\r\n                >\r\n                    <h2 className=\"text-xl font-bold text-white mb-6 flex items-center gap-3\">\r\n                        <div className=\"p-2 bg-gradient-to-br from-emerald-500 to-cyan-500 rounded-xl\">\r\n                            <TagIcon size={20} className=\"text-white\" />\r\n                        </div>\r\n                        All Tags\r\n                        <span className=\"ml-auto text-sm font-normal text-gray-400 bg-white/5 px-3 py-1 rounded-full\">\r\n                            {tags.length} {tags.length === 1 ? 'tag' : 'tags'}\r\n                        </span>\r\n                    </h2>\r\n\r\n                    {isLoading ? (\r\n                        <div className=\"flex items-center justify-center py-16\">\r\n                            <motion.div\r\n                                animate={{ rotate: 360 }}\r\n                                transition={{ duration: 1, repeat: Infinity, ease: 'linear' }}\r\n                                className=\"w-10 h-10 border-3 border-white/20 border-t-white rounded-full\"\r\n                            />\r\n                        </div>\r\n                    ) : tags.length === 0 ? (\r\n                        <motion.div\r\n                            initial={{ opacity: 0 }}\r\n                            animate={{ opacity: 1 }}\r\n                            className=\"text-center py-16\"\r\n                        >\r\n                            <div className=\"w-20 h-20 mx-auto mb-4 bg-white/5 rounded-full flex items-center justify-center\">\r\n                                <TagIcon size={32} className=\"text-gray-500\" />\r\n                            </div>\r\n                            <p className=\"text-gray-400 font-medium\">No tags created yet</p>\r\n                            <p className=\"text-gray-500 text-sm mt-1\">Create your first tag above!</p>\r\n                        </motion.div>\r\n                    ) : (\r\n                        <div className=\"space-y-3\">\r\n                            <AnimatePresence mode=\"popLayout\">\r\n                                {tags.map((tag, index) => (\r\n                                    <motion.div\r\n                                        key={tag.id}\r\n                                        layout\r\n                                        initial={{ opacity: 0, x: -30, scale: 0.9 }}\r\n                                        animate={{ opacity: 1, x: 0, scale: 1 }}\r\n                                        exit={{ opacity: 0, x: 30, scale: 0.9 }}\r\n                                        transition={{ type: 'spring', stiffness: 300, damping: 25, delay: index * 0.05 }}\r\n                                        className=\"flex items-center justify-between p-4 bg-white/5 hover:bg-white/[0.08] rounded-2xl group transition-all border border-transparent hover:border-white/10\"\r\n                                    >\r\n                                        {editingTag?.id === tag.id ? (\r\n                                            <motion.div\r\n                                                initial={{ opacity: 0 }}\r\n                                                animate={{ opacity: 1 }}\r\n                                                className=\"flex items-center gap-4 flex-1\"\r\n                                            >\r\n                                                <motion.div\r\n                                                    whileHover={{ scale: 1.1 }}\r\n                                                    whileTap={{ scale: 0.9 }}\r\n                                                    className=\"w-8 h-8 rounded-xl cursor-pointer border-2 border-white/20 shadow-lg relative overflow-hidden\"\r\n                                                    style={{ backgroundColor: editColor }}\r\n                                                    onClick={() => {\r\n                                                        const idx = TAG_COLORS.findIndex(c => c.color === editColor);\r\n                                                        setEditColor(TAG_COLORS[(idx + 1) % TAG_COLORS.length].color);\r\n                                                    }}\r\n                                                    title=\"Click to change color\"\r\n                                                >\r\n                                                    <div className=\"absolute inset-0 bg-gradient-to-br from-white/20 to-transparent\" />\r\n                                                </motion.div>\r\n                                                <input\r\n                                                    type=\"text\"\r\n                                                    value={editName}\r\n                                                    onChange={(e) => setEditName(e.target.value)}\r\n                                                    onKeyDown={(e) => e.key === 'Enter' && handleUpdateTag()}\r\n                                                    className=\"flex-1 px-4 py-2.5 bg-black/50 border border-white/10 rounded-xl text-white focus:outline-none focus:ring-2 focus:ring-blue-500/50\"\r\n                                                    autoFocus\r\n                                                />\r\n                                                <motion.button\r\n                                                    whileHover={{ scale: 1.1 }}\r\n                                                    whileTap={{ scale: 0.9 }}\r\n                                                    onClick={handleUpdateTag}\r\n                                                    className=\"p-2.5 bg-emerald-500 text-white rounded-xl hover:bg-emerald-400 transition-colors\"\r\n                                                >\r\n                                                    <Check size={18} />\r\n                                                </motion.button>\r\n                                                <motion.button\r\n                                                    whileHover={{ scale: 1.1 }}\r\n                                                    whileTap={{ scale: 0.9 }}\r\n                                                    onClick={() => setEditingTag(null)}\r\n                                                    className=\"p-2.5 bg-white/10 text-white rounded-xl hover:bg-white/20 transition-colors\"\r\n                                                >\r\n                                                    <X size={18} />\r\n                                                </motion.button>\r\n                                            </motion.div>\r\n                                        ) : (\r\n                                            <>\r\n                                                <div className=\"flex items-center gap-4\">\r\n                                                    <div\r\n                                                        className=\"w-8 h-8 rounded-xl shadow-lg relative overflow-hidden\"\r\n                                                        style={{ backgroundColor: tag.color }}\r\n                                                    >\r\n                                                        <div className=\"absolute inset-0 bg-gradient-to-br from-white/20 to-transparent\" />\r\n                                                    </div>\r\n                                                    <span className=\"font-semibold text-white text-lg\">#{tag.name}</span>\r\n                                                </div>\r\n                                                <div className=\"flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-all duration-200\">\r\n                                                    <motion.button\r\n                                                        whileHover={{ scale: 1.1 }}\r\n                                                        whileTap={{ scale: 0.9 }}\r\n                                                        onClick={() => startEdit(tag)}\r\n                                                        className=\"p-2.5 hover:bg-white/10 rounded-xl text-gray-400 hover:text-white transition-colors\"\r\n                                                    >\r\n                                                        <Edit3 size={18} />\r\n                                                    </motion.button>\r\n                                                    <motion.button\r\n                                                        whileHover={{ scale: 1.1 }}\r\n                                                        whileTap={{ scale: 0.9 }}\r\n                                                        onClick={() => setDeleteConfirm(tag)}\r\n                                                        className=\"p-2.5 hover:bg-red-500/20 rounded-xl text-gray-400 hover:text-red-400 transition-colors\"\r\n                                                    >\r\n                                                        <Trash2 size={18} />\r\n                                                    </motion.button>\r\n                                                </div>\r\n                                            </>\r\n                                        )}\r\n                                    </motion.div>\r\n                                ))}\r\n                            </AnimatePresence>\r\n                        </div>\r\n                    )}\r\n                </motion.div>\r\n            </div>\r\n\r\n            {/* Delete Confirmation Modal */}\r\n            <AnimatePresence>\r\n                {deleteConfirm && (\r\n                    <motion.div\r\n                        initial={{ opacity: 0 }}\r\n                        animate={{ opacity: 1 }}\r\n                        exit={{ opacity: 0 }}\r\n                        className=\"fixed inset-0 bg-black/70 backdrop-blur-md flex items-center justify-center z-50 p-4\"\r\n                        onClick={() => setDeleteConfirm(null)}\r\n                    >\r\n                        <motion.div\r\n                            initial={{ scale: 0.9, opacity: 0, y: 20 }}\r\n                            animate={{ scale: 1, opacity: 1, y: 0 }}\r\n                            exit={{ scale: 0.9, opacity: 0, y: 20 }}\r\n                            transition={{ type: 'spring', stiffness: 300, damping: 25 }}\r\n                            className=\"bg-neutral-900 rounded-3xl shadow-2xl p-8 max-w-md w-full border border-white/10\"\r\n                            onClick={(e) => e.stopPropagation()}\r\n                        >\r\n                            <div className=\"flex items-center gap-4 mb-6\">\r\n                                <motion.div\r\n                                    initial={{ scale: 0 }}\r\n                                    animate={{ scale: 1 }}\r\n                                    transition={{ type: 'spring', stiffness: 300, damping: 20, delay: 0.1 }}\r\n                                    className=\"p-4 bg-red-500/20 rounded-2xl\"\r\n                                >\r\n                                    <Trash2 size={28} className=\"text-red-400\" />\r\n                                </motion.div>\r\n                                <div>\r\n                                    <h3 className=\"text-xl font-bold text-white\">Delete Tag?</h3>\r\n                                    <p className=\"text-sm text-gray-400\">This action cannot be undone</p>\r\n                                </div>\r\n                            </div>\r\n                            <p className=\"text-gray-300 mb-8 leading-relaxed\">\r\n                                Are you sure you want to delete <strong className=\"text-white\">#{deleteConfirm.name}</strong>?\r\n                                This will also remove it from all notes using this tag.\r\n                            </p>\r\n                            <div className=\"flex gap-4\">\r\n                                <motion.button\r\n                                    whileHover={{ scale: 1.02 }}\r\n                                    whileTap={{ scale: 0.98 }}\r\n                                    onClick={() => setDeleteConfirm(null)}\r\n                                    className=\"flex-1 px-6 py-4 bg-white/10 text-white font-bold rounded-2xl hover:bg-white/15 transition-colors\"\r\n                                >\r\n                                    Cancel\r\n                                </motion.button>\r\n                                <motion.button\r\n                                    whileHover={{ scale: 1.02 }}\r\n                                    whileTap={{ scale: 0.98 }}\r\n                                    onClick={handleDeleteTag}\r\n                                    className=\"flex-1 px-6 py-4 bg-red-500 text-white font-bold rounded-2xl hover:bg-red-400 transition-colors\"\r\n                                >\r\n                                    Delete Tag\r\n                                </motion.button>\r\n                            </div>\r\n                        </motion.div>\r\n                    </motion.div>\r\n                )}\r\n            </AnimatePresence>\r\n        </div>\r\n    );\r\n}\r\n"],"names":[],"mappings":"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"}}]
}