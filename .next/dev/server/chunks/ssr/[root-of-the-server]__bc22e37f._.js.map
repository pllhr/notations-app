{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/ROCKETSEAT%20UPAR%20DROPBOX/ANALISE%20DE%20DADOS/notations/lib/db.ts"],"sourcesContent":["import { Pool } from '@neondatabase/serverless';\n\n// Prevent multiple connections in dev mode\nconst globalForDb = globalThis as unknown as {\n    conn: Pool | undefined;\n};\n\nconst pool = globalForDb.conn ?? new Pool({ connectionString: process.env.DATABASE_URL });\n\nif (process.env.NODE_ENV !== 'production') globalForDb.conn = pool;\n\nexport default pool;"],"names":[],"mappings":";;;;AAAA;;AAEA,2CAA2C;AAC3C,MAAM,cAAc;AAIpB,MAAM,OAAO,YAAY,IAAI,IAAI,IAAI,8JAAI,CAAC;IAAE,kBAAkB,QAAQ,GAAG,CAAC,YAAY;AAAC;AAEvF,wCAA2C,YAAY,IAAI,GAAG;uCAE/C"}},
    {"offset": {"line": 27, "column": 0}, "map": {"version":3,"sources":["file:///D:/ROCKETSEAT%20UPAR%20DROPBOX/ANALISE%20DE%20DADOS/notations/auth.config.ts"],"sourcesContent":["import type { NextAuthConfig } from 'next-auth';\r\n\r\nexport const authConfig = {\r\n    pages: {\r\n        signIn: '/login',\r\n    },\r\n    callbacks: {\r\n        authorized({ auth, request: { nextUrl } }) {\r\n            const isLoggedIn = !!auth?.user;\r\n\r\n            // Define public routes that don't require authentication\r\n            const publicRoutes = ['/login', '/register'];\r\n            const isOnPublicRoute = publicRoutes.some(route => nextUrl.pathname.startsWith(route));\r\n\r\n            if (isOnPublicRoute) {\r\n                if (isLoggedIn) {\r\n                    // Redirect logged-in users to home if they try to access login/register\r\n                    return Response.redirect(new URL('/', nextUrl));\r\n                }\r\n                return true;\r\n            }\r\n\r\n            // Protect all other routes\r\n            if (!isLoggedIn) {\r\n                return false; // Redirects to signIn page\r\n            }\r\n\r\n            return true;\r\n        },\r\n    },\r\n    providers: [], // Add providers with an empty array for now\r\n} satisfies NextAuthConfig;\r\n"],"names":[],"mappings":";;;;AAEO,MAAM,aAAa;IACtB,OAAO;QACH,QAAQ;IACZ;IACA,WAAW;QACP,YAAW,EAAE,IAAI,EAAE,SAAS,EAAE,OAAO,EAAE,EAAE;YACrC,MAAM,aAAa,CAAC,CAAC,MAAM;YAE3B,yDAAyD;YACzD,MAAM,eAAe;gBAAC;gBAAU;aAAY;YAC5C,MAAM,kBAAkB,aAAa,IAAI,CAAC,CAAA,QAAS,QAAQ,QAAQ,CAAC,UAAU,CAAC;YAE/E,IAAI,iBAAiB;gBACjB,IAAI,YAAY;oBACZ,wEAAwE;oBACxE,OAAO,SAAS,QAAQ,CAAC,IAAI,IAAI,KAAK;gBAC1C;gBACA,OAAO;YACX;YAEA,2BAA2B;YAC3B,IAAI,CAAC,YAAY;gBACb,OAAO,OAAO,2BAA2B;YAC7C;YAEA,OAAO;QACX;IACJ;IACA,WAAW,EAAE;AACjB"}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///D:/ROCKETSEAT%20UPAR%20DROPBOX/ANALISE%20DE%20DADOS/notations/auth.ts"],"sourcesContent":["import NextAuth from 'next-auth';\r\nimport Credentials from 'next-auth/providers/credentials';\r\nimport { z } from 'zod';\r\nimport bcrypt from 'bcryptjs';\r\nimport pool from './lib/db';\r\nimport { User } from './types';\r\nimport { authConfig } from './auth.config';\r\n\r\nasync function getUser(email: string): Promise<User & { password_hash: string } | null> {\r\n    try {\r\n        const result = await pool.query('SELECT * FROM users WHERE email = $1', [email]);\r\n        return result.rows[0] || null;\r\n    } catch (error) {\r\n        console.error('Failed to fetch user:', error);\r\n        throw new Error('Failed to fetch user.');\r\n    }\r\n}\r\n\r\nexport const { auth, signIn, signOut, handlers } = NextAuth({\r\n    ...authConfig,\r\n    callbacks: {\r\n        ...authConfig.callbacks,\r\n        async session({ session, token }) {\r\n            if (token.sub && session.user) {\r\n                session.user.id = token.sub;\r\n            }\r\n            if (token.role && session.user) {\r\n                session.user.role = token.role as 'USER' | 'ADMIN';\r\n            }\r\n            if (token.createdAt && session.user) {\r\n                session.user.createdAt = token.createdAt as number;\r\n            }\r\n            if (token.name && session.user) {\r\n                session.user.name = token.name;\r\n            }\r\n            if (token.image && session.user) {\r\n                session.user.image = token.image as string;\r\n            }\r\n            return session;\r\n        },\r\n        async jwt({ token, user, trigger, session }) {\r\n            if (user) {\r\n                token.role = (user as any).role;\r\n                token.createdAt = (user as any).created_at;\r\n                token.name = user.name;\r\n\r\n                // Prevent large base64 images from bloating the cookie\r\n                if (user.image && user.image.length < 2000) {\r\n                    token.image = user.image;\r\n                } else {\r\n                    console.warn(\"User image is too large for session cookie, skipping.\");\r\n                    token.image = null; // Or set a default placeholder if needed\r\n                }\r\n            }\r\n\r\n            // Update token if session is updated (e.g. name change)\r\n            if (trigger === \"update\" && session) {\r\n                token.name = session.user.name;\r\n                if (session.user.image && session.user.image.length < 2000) {\r\n                    token.image = session.user.image;\r\n                }\r\n            }\r\n\r\n            return token;\r\n        },\r\n    },\r\n    providers: [\r\n        Credentials({\r\n            async authorize(credentials) {\r\n                const parsedCredentials = z\r\n                    .object({ email: z.string().email(), password: z.string().min(6) })\r\n                    .safeParse(credentials);\r\n\r\n                if (parsedCredentials.success) {\r\n                    const { email, password } = parsedCredentials.data;\r\n                    const user = await getUser(email);\r\n                    if (!user) return null;\r\n\r\n                    const passwordsMatch = await bcrypt.compare(password, user.password_hash);\r\n                    if (passwordsMatch) return user;\r\n                }\r\n\r\n                console.log('Invalid credentials');\r\n                return null;\r\n            },\r\n        }),\r\n    ],\r\n});\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;;;AAEA,eAAe,QAAQ,KAAa;IAChC,IAAI;QACA,MAAM,SAAS,MAAM,oHAAI,CAAC,KAAK,CAAC,wCAAwC;YAAC;SAAM;QAC/E,OAAO,OAAO,IAAI,CAAC,EAAE,IAAI;IAC7B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,yBAAyB;QACvC,MAAM,IAAI,MAAM;IACpB;AACJ;AAEO,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,GAAG,IAAA,gKAAQ,EAAC;IACxD,GAAG,4HAAU;IACb,WAAW;QACP,GAAG,4HAAU,CAAC,SAAS;QACvB,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC5B,IAAI,MAAM,GAAG,IAAI,QAAQ,IAAI,EAAE;gBAC3B,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,GAAG;YAC/B;YACA,IAAI,MAAM,IAAI,IAAI,QAAQ,IAAI,EAAE;gBAC5B,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YAClC;YACA,IAAI,MAAM,SAAS,IAAI,QAAQ,IAAI,EAAE;gBACjC,QAAQ,IAAI,CAAC,SAAS,GAAG,MAAM,SAAS;YAC5C;YACA,IAAI,MAAM,IAAI,IAAI,QAAQ,IAAI,EAAE;gBAC5B,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YAClC;YACA,IAAI,MAAM,KAAK,IAAI,QAAQ,IAAI,EAAE;gBAC7B,QAAQ,IAAI,CAAC,KAAK,GAAG,MAAM,KAAK;YACpC;YACA,OAAO;QACX;QACA,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE;YACvC,IAAI,MAAM;gBACN,MAAM,IAAI,GAAG,AAAC,KAAa,IAAI;gBAC/B,MAAM,SAAS,GAAG,AAAC,KAAa,UAAU;gBAC1C,MAAM,IAAI,GAAG,KAAK,IAAI;gBAEtB,uDAAuD;gBACvD,IAAI,KAAK,KAAK,IAAI,KAAK,KAAK,CAAC,MAAM,GAAG,MAAM;oBACxC,MAAM,KAAK,GAAG,KAAK,KAAK;gBAC5B,OAAO;oBACH,QAAQ,IAAI,CAAC;oBACb,MAAM,KAAK,GAAG,MAAM,yCAAyC;gBACjE;YACJ;YAEA,wDAAwD;YACxD,IAAI,YAAY,YAAY,SAAS;gBACjC,MAAM,IAAI,GAAG,QAAQ,IAAI,CAAC,IAAI;gBAC9B,IAAI,QAAQ,IAAI,CAAC,KAAK,IAAI,QAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,MAAM;oBACxD,MAAM,KAAK,GAAG,QAAQ,IAAI,CAAC,KAAK;gBACpC;YACJ;YAEA,OAAO;QACX;IACJ;IACA,WAAW;QACP,IAAA,qKAAW,EAAC;YACR,MAAM,WAAU,WAAW;gBACvB,MAAM,oBAAoB,uKAAC,CACtB,MAAM,CAAC;oBAAE,OAAO,uKAAC,CAAC,MAAM,GAAG,KAAK;oBAAI,UAAU,uKAAC,CAAC,MAAM,GAAG,GAAG,CAAC;gBAAG,GAChE,SAAS,CAAC;gBAEf,IAAI,kBAAkB,OAAO,EAAE;oBAC3B,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,kBAAkB,IAAI;oBAClD,MAAM,OAAO,MAAM,QAAQ;oBAC3B,IAAI,CAAC,MAAM,OAAO;oBAElB,MAAM,iBAAiB,MAAM,4IAAM,CAAC,OAAO,CAAC,UAAU,KAAK,aAAa;oBACxE,IAAI,gBAAgB,OAAO;gBAC/B;gBAEA,QAAQ,GAAG,CAAC;gBACZ,OAAO;YACX;QACJ;KACH;AACL"}},
    {"offset": {"line": 167, "column": 0}, "map": {"version":3,"sources":["file:///D:/ROCKETSEAT%20UPAR%20DROPBOX/ANALISE%20DE%20DADOS/notations/app/actions.ts"],"sourcesContent":["'use server';\n\nimport pool from '../lib/db';\nimport { Note } from '../types';\n\nasync function ensureTable() {\n  try {\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS notes (\n        id TEXT PRIMARY KEY,\n        title TEXT,\n        data JSONB NOT NULL\n      );\n    `);\n\n    // Create Users Table\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id TEXT PRIMARY KEY,\n        email TEXT UNIQUE NOT NULL,\n        password_hash TEXT NOT NULL,\n        role TEXT NOT NULL DEFAULT 'USER',\n        created_at BIGINT NOT NULL,\n        name TEXT,\n        image TEXT\n      );\n    `);\n\n    // Add columns if they don't exist (migration)\n    try {\n      await pool.query(`ALTER TABLE users ADD COLUMN IF NOT EXISTS name TEXT;`);\n      await pool.query(`ALTER TABLE users ADD COLUMN IF NOT EXISTS image TEXT;`);\n    } catch (e) {\n      console.log(\"Columns might already exist\");\n    }\n\n  } catch (e) {\n    console.error(\"Failed to ensure tables exist:\", e);\n  }\n}\n\n// ... (rest of file)\n\nexport async function updateUserProfile(name: string, image: string) {\n  try {\n    const session = await import('../auth').then(mod => mod.auth());\n    if (!session?.user?.email) return { error: 'Not authenticated' };\n\n    await pool.query(\n      'UPDATE users SET name = $1, image = $2 WHERE email = $3',\n      [name, image, session.user.email]\n    );\n    return { success: true };\n  } catch (error: any) {\n    if (error.code === '42703') { // Undefined column\n      await ensureTable();\n      try {\n        const session = await import('../auth').then(mod => mod.auth());\n        if (!session?.user?.email) return { error: 'Not authenticated' };\n\n        await pool.query(\n          'UPDATE users SET name = $1, image = $2 WHERE email = $3',\n          [name, image, session.user.email]\n        );\n        return { success: true };\n      } catch (retryError) {\n        console.error('Failed to update profile after migration:', retryError);\n        return { error: 'Failed to update profile' };\n      }\n    }\n    console.error('Failed to update profile:', error);\n    return { error: 'Failed to update profile' };\n  }\n}\n\nexport async function signOutAction() {\n  const { signOut } = await import('../auth');\n  await signOut({ redirectTo: '/login' });\n}\n\nexport async function getNotes(): Promise<Note[]> {\n  // ... (rest of file)\n  try {\n    const result = await pool.query('SELECT data FROM notes');\n    return result.rows\n      .map(row => row.data)\n      .filter((n): n is Note => n !== null && typeof n === 'object' && 'id' in n);\n  } catch (e: any) {\n    // Handle case where table might not exist yet\n    if (e.code === '42P01') {\n      await ensureTable();\n      return [];\n    }\n    // Handle case where column might not exist (schema mismatch)\n    if (e.code === '42703') {\n      await fixSchema();\n      // Retry fetch\n      try {\n        const retryResult = await pool.query('SELECT data FROM notes');\n        return retryResult.rows\n          .map(row => row.data)\n          .filter((n): n is Note => n !== null && typeof n === 'object' && 'id' in n);\n      } catch (retryError) {\n        console.error(\"Retry failed after schema fix:\", retryError);\n        return [];\n      }\n    }\n    console.error(\"Database Error:\", e);\n    return [];\n  }\n}\n\nasync function fixSchema() {\n  try {\n    await pool.query(`\n            ALTER TABLE notes ADD COLUMN IF NOT EXISTS data JSONB;\n        `);\n  } catch (e) {\n    console.error(\"Failed to fix schema:\", e);\n  }\n}\n\nexport async function saveNote(note: Note) {\n  try {\n    await pool.query(\n      `INSERT INTO notes (id, title, data) VALUES ($1, $2, $3) \n       ON CONFLICT (id) DO UPDATE SET title = $2, data = $3`,\n      [note.id, note.title || '', JSON.stringify(note)]\n    );\n  } catch (e: any) {\n    if (e.code === '42P01') {\n      await ensureTable();\n      // Retry once\n      await pool.query(\n        `INSERT INTO notes (id, title, data) VALUES ($1, $2, $3) \n             ON CONFLICT (id) DO UPDATE SET title = $2, data = $3`,\n        [note.id, note.title || '', JSON.stringify(note)]\n      );\n    } else if (e.code === '42703') {\n      await fixSchema();\n      // Retry once\n      await pool.query(\n        `INSERT INTO notes (id, title, data) VALUES ($1, $2, $3) \n             ON CONFLICT (id) DO UPDATE SET title = $2, data = $3`,\n        [note.id, note.title || '', JSON.stringify(note)]\n      );\n    } else {\n      throw e;\n    }\n  }\n}\n\nexport async function deleteNoteAction(id: string) {\n  try {\n    await pool.query('DELETE FROM notes WHERE id = $1', [id]);\n  } catch (e) {\n    console.error(\"Delete Error:\", e);\n  }\n}\n\nexport async function syncNotes(notes: Note[]) {\n  // Utility for bulk updates if needed, though granular is better for performance\n  for (const note of notes) {\n    await saveNote(note);\n  }\n}\n\nimport bcrypt from 'bcryptjs';\nimport { signIn } from '../auth';\nimport { AuthError } from 'next-auth';\n\nexport async function registerUser(formData: FormData) {\n  const email = formData.get('email') as string;\n  const password = formData.get('password') as string;\n  const role = formData.get('role') as 'USER' | 'ADMIN' || 'USER';\n\n  if (!email || !password) {\n    return { error: 'Email and password are required.' };\n  }\n\n  // Ensure table exists before registering\n  await ensureTable();\n\n  const hashedPassword = await bcrypt.hash(password, 10);\n  const id = crypto.randomUUID();\n\n  try {\n    await pool.query(\n      `INSERT INTO users (id, email, password_hash, role, created_at) VALUES ($1, $2, $3, $4, $5)`,\n      [id, email, hashedPassword, role, Date.now()]\n    );\n    return { success: true };\n  } catch (error: any) {\n    if (error.code === '23505') { // Unique violation\n      return { error: 'User already exists.' };\n    }\n    console.error('Registration error:', error);\n    return { error: 'Failed to register user.' };\n  }\n}\n\nexport async function authenticate(prevState: string | undefined, formData: FormData) {\n  try {\n    await signIn('credentials', {\n      ...Object.fromEntries(formData),\n      redirectTo: '/',\n    });\n  } catch (error) {\n    if (error instanceof AuthError) {\n      switch (error.type) {\n        case 'CredentialsSignin':\n          return 'Invalid credentials.';\n        default:\n          return 'Something went wrong.';\n      }\n    }\n    throw error;\n  }\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 438, "column": 0}, "map": {"version":3,"sources":["file:///D:/ROCKETSEAT%20UPAR%20DROPBOX/ANALISE%20DE%20DADOS/notations/.next-internal/server/app/login/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {registerUser as '4096e6d625be476a95ef4a4ccfccb665ab488c4578'} from 'ACTIONS_MODULE0'\nexport {authenticate as '6090501925620fd29c207a1b20c4264c38d5733a74'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA"}}]
}