{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/ANALISE%20DE%20DADOS/notations/lib/db.ts"],"sourcesContent":["import { Pool } from '@neondatabase/serverless';\n\n// Prevent multiple connections in dev mode\nconst globalForDb = globalThis as unknown as {\n    conn: Pool | undefined;\n};\n\nconst pool = globalForDb.conn ?? new Pool({ connectionString: process.env.DATABASE_URL });\n\nif (process.env.NODE_ENV !== 'production') globalForDb.conn = pool;\n\nexport default pool;"],"names":[],"mappings":";;;;AAAA;;AAEA,2CAA2C;AAC3C,MAAM,cAAc;AAIpB,MAAM,OAAO,YAAY,IAAI,IAAI,IAAI,8JAAI,CAAC;IAAE,kBAAkB,QAAQ,GAAG,CAAC,YAAY;AAAC;AAEvF,wCAA2C,YAAY,IAAI,GAAG;uCAE/C"}},
    {"offset": {"line": 27, "column": 0}, "map": {"version":3,"sources":["file:///D:/ANALISE%20DE%20DADOS/notations/auth.config.ts"],"sourcesContent":["import type { NextAuthConfig } from 'next-auth';\r\n\r\nexport const authConfig = {\r\n    pages: {\r\n        signIn: '/login',\r\n    },\r\n    callbacks: {\r\n        authorized({ auth, request: { nextUrl } }) {\r\n            const isLoggedIn = !!auth?.user;\r\n\r\n            // Define public routes that don't require authentication\r\n            const publicRoutes = ['/login', '/register'];\r\n            const isOnPublicRoute = publicRoutes.some(route => nextUrl.pathname.startsWith(route));\r\n\r\n            if (isOnPublicRoute) {\r\n                if (isLoggedIn) {\r\n                    // Redirect logged-in users to home if they try to access login/register\r\n                    return Response.redirect(new URL('/', nextUrl));\r\n                }\r\n                return true;\r\n            }\r\n\r\n            // Protect all other routes\r\n            if (!isLoggedIn) {\r\n                return false; // Redirects to signIn page\r\n            }\r\n\r\n            return true;\r\n        },\r\n    },\r\n    providers: [], // Add providers with an empty array for now\r\n} satisfies NextAuthConfig;\r\n"],"names":[],"mappings":";;;;AAEO,MAAM,aAAa;IACtB,OAAO;QACH,QAAQ;IACZ;IACA,WAAW;QACP,YAAW,EAAE,IAAI,EAAE,SAAS,EAAE,OAAO,EAAE,EAAE;YACrC,MAAM,aAAa,CAAC,CAAC,MAAM;YAE3B,yDAAyD;YACzD,MAAM,eAAe;gBAAC;gBAAU;aAAY;YAC5C,MAAM,kBAAkB,aAAa,IAAI,CAAC,CAAA,QAAS,QAAQ,QAAQ,CAAC,UAAU,CAAC;YAE/E,IAAI,iBAAiB;gBACjB,IAAI,YAAY;oBACZ,wEAAwE;oBACxE,OAAO,SAAS,QAAQ,CAAC,IAAI,IAAI,KAAK;gBAC1C;gBACA,OAAO;YACX;YAEA,2BAA2B;YAC3B,IAAI,CAAC,YAAY;gBACb,OAAO,OAAO,2BAA2B;YAC7C;YAEA,OAAO;QACX;IACJ;IACA,WAAW,EAAE;AACjB"}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///D:/ANALISE%20DE%20DADOS/notations/lib/data.ts"],"sourcesContent":["import pool from './db';\r\nimport { User } from '../types';\r\n\r\nexport async function getUserByEmail(email: string): Promise<User & { password_hash: string } | null> {\r\n    try {\r\n        const result = await pool.query('SELECT * FROM users WHERE email = $1', [email]);\r\n        return result.rows[0] || null;\r\n    } catch (error) {\r\n        console.error('Failed to fetch user:', error);\r\n        throw new Error('Failed to fetch user.');\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;;AAGO,eAAe,eAAe,KAAa;IAC9C,IAAI;QACA,MAAM,SAAS,MAAM,oHAAI,CAAC,KAAK,CAAC,wCAAwC;YAAC;SAAM;QAC/E,OAAO,OAAO,IAAI,CAAC,EAAE,IAAI;IAC7B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,yBAAyB;QACvC,MAAM,IAAI,MAAM;IACpB;AACJ"}},
    {"offset": {"line": 85, "column": 0}, "map": {"version":3,"sources":["file:///D:/ANALISE%20DE%20DADOS/notations/auth.ts"],"sourcesContent":["import NextAuth from 'next-auth';\r\nimport Credentials from 'next-auth/providers/credentials';\r\nimport { z } from 'zod';\r\nimport bcrypt from 'bcryptjs';\r\nimport { authConfig } from './auth.config';\r\nimport { getUserByEmail } from './lib/data';\r\n\r\nexport const { auth, signIn, signOut, handlers } = NextAuth({\r\n    ...authConfig,\r\n    callbacks: {\r\n        ...authConfig.callbacks,\r\n        async session({ session, token }) {\r\n            if (token.sub && session.user) {\r\n                session.user.id = token.sub;\r\n            }\r\n            if (token.role && session.user) {\r\n                session.user.role = token.role as 'USER' | 'ADMIN';\r\n            }\r\n            if (token.createdAt && session.user) {\r\n                session.user.createdAt = token.createdAt as number;\r\n            }\r\n            if (token.name && session.user) {\r\n                session.user.name = token.name;\r\n            }\r\n            // Image is NOT stored in session anymore to prevent header overflow\r\n            return session;\r\n        },\r\n        async jwt({ token, user, trigger, session }) {\r\n            if (user) {\r\n                token.role = (user as any).role;\r\n                token.createdAt = (user as any).created_at;\r\n                token.name = user.name;\r\n                // token.image is intentionally omitted\r\n            }\r\n\r\n            // Update token if session is updated (e.g. name change)\r\n            if (trigger === \"update\" && session) {\r\n                token.name = session.user.name;\r\n            }\r\n\r\n            return token;\r\n        },\r\n    },\r\n    providers: [\r\n        Credentials({\r\n            async authorize(credentials) {\r\n                const parsedCredentials = z\r\n                    .object({ email: z.string().email(), password: z.string().min(6) })\r\n                    .safeParse(credentials);\r\n\r\n                if (parsedCredentials.success) {\r\n                    const { email, password } = parsedCredentials.data;\r\n                    const user = await getUserByEmail(email);\r\n                    if (!user) return null;\r\n\r\n                    const passwordsMatch = await bcrypt.compare(password, user.password_hash);\r\n                    if (passwordsMatch) return user;\r\n                }\r\n\r\n                console.log('Invalid credentials');\r\n                return null;\r\n            },\r\n        }),\r\n    ],\r\n});\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;AAEO,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,GAAG,IAAA,gKAAQ,EAAC;IACxD,GAAG,4HAAU;IACb,WAAW;QACP,GAAG,4HAAU,CAAC,SAAS;QACvB,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC5B,IAAI,MAAM,GAAG,IAAI,QAAQ,IAAI,EAAE;gBAC3B,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,GAAG;YAC/B;YACA,IAAI,MAAM,IAAI,IAAI,QAAQ,IAAI,EAAE;gBAC5B,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YAClC;YACA,IAAI,MAAM,SAAS,IAAI,QAAQ,IAAI,EAAE;gBACjC,QAAQ,IAAI,CAAC,SAAS,GAAG,MAAM,SAAS;YAC5C;YACA,IAAI,MAAM,IAAI,IAAI,QAAQ,IAAI,EAAE;gBAC5B,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YAClC;YACA,oEAAoE;YACpE,OAAO;QACX;QACA,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE;YACvC,IAAI,MAAM;gBACN,MAAM,IAAI,GAAG,AAAC,KAAa,IAAI;gBAC/B,MAAM,SAAS,GAAG,AAAC,KAAa,UAAU;gBAC1C,MAAM,IAAI,GAAG,KAAK,IAAI;YACtB,uCAAuC;YAC3C;YAEA,wDAAwD;YACxD,IAAI,YAAY,YAAY,SAAS;gBACjC,MAAM,IAAI,GAAG,QAAQ,IAAI,CAAC,IAAI;YAClC;YAEA,OAAO;QACX;IACJ;IACA,WAAW;QACP,IAAA,qKAAW,EAAC;YACR,MAAM,WAAU,WAAW;gBACvB,MAAM,oBAAoB,uKAAC,CACtB,MAAM,CAAC;oBAAE,OAAO,uKAAC,CAAC,MAAM,GAAG,KAAK;oBAAI,UAAU,uKAAC,CAAC,MAAM,GAAG,GAAG,CAAC;gBAAG,GAChE,SAAS,CAAC;gBAEf,IAAI,kBAAkB,OAAO,EAAE;oBAC3B,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,kBAAkB,IAAI;oBAClD,MAAM,OAAO,MAAM,IAAA,6HAAc,EAAC;oBAClC,IAAI,CAAC,MAAM,OAAO;oBAElB,MAAM,iBAAiB,MAAM,4IAAM,CAAC,OAAO,CAAC,UAAU,KAAK,aAAa;oBACxE,IAAI,gBAAgB,OAAO;gBAC/B;gBAEA,QAAQ,GAAG,CAAC;gBACZ,OAAO;YACX;QACJ;KACH;AACL"}},
    {"offset": {"line": 166, "column": 0}, "map": {"version":3,"sources":["file:///D:/ANALISE%20DE%20DADOS/notations/app/actions.ts"],"sourcesContent":["'use server';\n\nimport pool from '../lib/db';\nimport { Note } from '../types';\nimport { z } from 'zod';\nimport bcrypt from 'bcryptjs';\nimport { signIn } from '../auth';\nimport { AuthError } from 'next-auth';\n\n// --- Zod Schemas ---\nconst UserRegistrationSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(6),\n  role: z.enum(['USER', 'ADMIN']).optional(),\n});\n\nconst UserProfileSchema = z.object({\n  name: z.string().min(1).max(100),\n  image: z.string().optional(), // Allow empty string or null\n});\n\nconst NoteBlockSchema = z.object({\n  id: z.string(),\n  type: z.enum(['paragraph', 'heading', 'todo', 'bullet', 'blockquote', 'code', 'image']),\n  content: z.string(),\n  checked: z.boolean().optional(),\n});\n\nconst NoteSchema = z.object({\n  id: z.string(),\n  title: z.string(),\n  blocks: z.array(NoteBlockSchema),\n  position: z.object({ x: z.number(), y: z.number() }),\n  connections: z.array(z.string()),\n  tags: z.array(z.string()).optional(),\n  createdAt: z.number(),\n  color: z.string().optional(),\n});\n\n// --- Helper Functions ---\n\nasync function withRetry<T>(fn: () => Promise<T>, retries = 3, delay = 1000): Promise<T> {\n  try {\n    return await fn();\n  } catch (error) {\n    if (retries <= 0) throw error;\n    await new Promise(resolve => setTimeout(resolve, delay));\n    return withRetry(fn, retries - 1, delay * 2);\n  }\n}\n\nasync function ensureTable() {\n  try {\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS notes (\n        id TEXT PRIMARY KEY,\n        title TEXT,\n        data JSONB NOT NULL\n      );\n    `);\n\n    // Create Users Table\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id TEXT PRIMARY KEY,\n        email TEXT UNIQUE NOT NULL,\n        password_hash TEXT NOT NULL,\n        role TEXT NOT NULL DEFAULT 'USER',\n        created_at BIGINT NOT NULL,\n        name TEXT,\n        image TEXT\n      );\n    `);\n\n    // Create Tags Table for global tag management\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS tags (\n        id TEXT PRIMARY KEY,\n        name TEXT UNIQUE NOT NULL,\n        color TEXT NOT NULL DEFAULT '#3b82f6',\n        created_at BIGINT NOT NULL\n      );\n    `);\n\n    // Add columns if they don't exist (migration)\n    try {\n      await pool.query(`ALTER TABLE users ADD COLUMN IF NOT EXISTS name TEXT;`);\n      await pool.query(`ALTER TABLE users ADD COLUMN IF NOT EXISTS image TEXT;`);\n    } catch (e) {\n      console.log(\"Columns might already exist\");\n    }\n\n  } catch (e) {\n    console.error(\"Failed to ensure tables exist:\", e);\n  }\n}\n\nasync function fixSchema() {\n  try {\n    await pool.query(`\n            ALTER TABLE notes ADD COLUMN IF NOT EXISTS data JSONB;\n        `);\n  } catch (e) {\n    console.error(\"Failed to fix schema:\", e);\n  }\n}\n\n// --- Actions ---\n\nexport async function updateUserProfile(name: string, image: string) {\n  const validation = UserProfileSchema.safeParse({ name, image });\n  if (!validation.success) {\n    return { error: 'Invalid profile data.' };\n  }\n\n  try {\n    const session = await import('../auth').then(mod => mod.auth());\n    if (!session?.user?.email) return { error: 'Not authenticated' };\n\n    await pool.query(\n      'UPDATE users SET name = $1, image = $2 WHERE email = $3',\n      [name, image, session.user.email]\n    );\n    return { success: true };\n  } catch (error: any) {\n    if (error.code === '42703') { // Undefined column\n      await ensureTable();\n      try {\n        const session = await import('../auth').then(mod => mod.auth());\n        if (!session?.user?.email) return { error: 'Not authenticated' };\n\n        await pool.query(\n          'UPDATE users SET name = $1, image = $2 WHERE email = $3',\n          [name, image, session.user.email]\n        );\n        return { success: true };\n      } catch (retryError) {\n        console.error('Failed to update profile after migration:', retryError);\n        return { error: 'Failed to update profile' };\n      }\n    }\n    console.error('Failed to update profile:', error);\n    return { error: 'Failed to update profile' };\n  }\n}\n\nexport async function signOutAction() {\n  const { signOut } = await import('../auth');\n  await signOut({ redirectTo: '/login' });\n}\n\nexport async function getNotes(): Promise<Note[]> {\n  try {\n    const result = await pool.query('SELECT data FROM notes');\n    return result.rows\n      .map(row => row.data)\n      .filter((n): n is Note => n !== null && typeof n === 'object' && 'id' in n);\n  } catch (e: any) {\n    // Handle case where table might not exist yet\n    if (e.code === '42P01') {\n      await ensureTable();\n      return [];\n    }\n    // Handle case where column might not exist (schema mismatch)\n    if (e.code === '42703') {\n      await fixSchema();\n      // Retry fetch\n      try {\n        const retryResult = await pool.query('SELECT data FROM notes');\n        return retryResult.rows\n          .map(row => row.data)\n          .filter((n): n is Note => n !== null && typeof n === 'object' && 'id' in n);\n      } catch (retryError) {\n        console.error(\"Retry failed after schema fix:\", retryError);\n        return [];\n      }\n    }\n    console.error(\"Database Error:\", e);\n    return [];\n  }\n}\n\nexport async function saveNote(note: Note) {\n  // Validate Note Structure\n  const validation = NoteSchema.safeParse(note);\n  if (!validation.success) {\n    console.error(\"Invalid note data:\", validation.error);\n    throw new Error(\"Invalid note data\");\n  }\n\n  await withRetry(async () => {\n    try {\n      await pool.query(\n        `INSERT INTO notes (id, title, data) VALUES ($1, $2, $3) \n         ON CONFLICT (id) DO UPDATE SET title = $2, data = $3`,\n        [note.id, note.title || '', JSON.stringify(note)]\n      );\n    } catch (e: any) {\n      if (e.code === '42P01') {\n        await ensureTable();\n        // Retry once immediately after table creation\n        await pool.query(\n          `INSERT INTO notes (id, title, data) VALUES ($1, $2, $3) \n               ON CONFLICT (id) DO UPDATE SET title = $2, data = $3`,\n          [note.id, note.title || '', JSON.stringify(note)]\n        );\n      } else if (e.code === '42703') {\n        await fixSchema();\n        // Retry once immediately after schema fix\n        await pool.query(\n          `INSERT INTO notes (id, title, data) VALUES ($1, $2, $3) \n               ON CONFLICT (id) DO UPDATE SET title = $2, data = $3`,\n          [note.id, note.title || '', JSON.stringify(note)]\n        );\n      } else {\n        throw e;\n      }\n    }\n  });\n}\n\nexport async function deleteNoteAction(id: string) {\n  if (!id || typeof id !== 'string') return; // Basic validation\n  try {\n    await withRetry(async () => await pool.query('DELETE FROM notes WHERE id = $1', [id]));\n  } catch (e) {\n    console.error(\"Delete Error:\", e);\n  }\n}\n\nexport async function syncNotes(notes: Note[]) {\n  const validation = z.array(NoteSchema).safeParse(notes);\n  if (!validation.success) {\n    console.error(\"Invalid notes data for sync\");\n    return;\n  }\n\n  // Process in chunks or sequentially to avoid overwhelming the DB, but with retry per note\n  for (const note of notes) {\n    await saveNote(note);\n  }\n}\n\nexport async function registerUser(formData: FormData) {\n  const rawData = {\n    email: formData.get('email'),\n    password: formData.get('password'),\n    role: formData.get('role') || 'USER',\n  };\n\n  const validation = UserRegistrationSchema.safeParse(rawData);\n\n  if (!validation.success) {\n    return { error: 'Invalid email or password (min 6 chars).' };\n  }\n\n  const { email, password, role } = validation.data;\n\n  // Ensure table exists before registering\n  await ensureTable();\n\n  const hashedPassword = await bcrypt.hash(password, 10);\n  const id = crypto.randomUUID();\n\n  try {\n    await pool.query(\n      `INSERT INTO users (id, email, password_hash, role, created_at) VALUES ($1, $2, $3, $4, $5)`,\n      [id, email, hashedPassword, role, Date.now()]\n    );\n    return { success: true };\n  } catch (error: any) {\n    if (error.code === '23505') { // Unique violation\n      return { error: 'User already exists.' };\n    }\n    console.error('Registration error:', error);\n    return { error: 'Failed to register user.' };\n  }\n}\n\nexport async function authenticate(prevState: string | undefined, formData: FormData) {\n  try {\n    await signIn('credentials', {\n      ...Object.fromEntries(formData),\n      redirectTo: '/',\n    });\n  } catch (error) {\n    if (error instanceof AuthError) {\n      switch (error.type) {\n        case 'CredentialsSignin':\n          return 'Invalid credentials.';\n        default:\n          return 'Something went wrong.';\n      }\n    }\n    throw error;\n  }\n}\n\n// --- Tag Management Actions ---\n\nimport { Tag } from '../types';\n\nconst TagSchema = z.object({\n  id: z.string(),\n  name: z.string().min(1).max(50),\n  color: z.string().regex(/^#[0-9a-fA-F]{6}$/),\n  createdAt: z.number(),\n});\n\nexport async function getTags(): Promise<Tag[]> {\n  try {\n    await ensureTable();\n    const result = await pool.query('SELECT id, name, color, created_at FROM tags ORDER BY name');\n    return result.rows.map(row => ({\n      id: row.id,\n      name: row.name,\n      color: row.color,\n      createdAt: Number(row.created_at),\n    }));\n  } catch (e: any) {\n    if (e.code === '42P01') {\n      await ensureTable();\n      return [];\n    }\n    console.error(\"Failed to get tags:\", e);\n    return [];\n  }\n}\n\nexport async function createTag(name: string, color: string): Promise<{ success?: boolean; error?: string; tag?: Tag }> {\n  const id = crypto.randomUUID();\n  const createdAt = Date.now();\n\n  const validation = TagSchema.safeParse({ id, name: name.trim().toLowerCase(), color, createdAt });\n  if (!validation.success) {\n    return { error: 'Invalid tag data' };\n  }\n\n  try {\n    await ensureTable();\n    await pool.query(\n      'INSERT INTO tags (id, name, color, created_at) VALUES ($1, $2, $3, $4)',\n      [id, name.trim().toLowerCase(), color, createdAt]\n    );\n    return { success: true, tag: { id, name: name.trim().toLowerCase(), color, createdAt } };\n  } catch (e: any) {\n    if (e.code === '23505') {\n      return { error: 'Tag already exists' };\n    }\n    console.error(\"Failed to create tag:\", e);\n    return { error: 'Failed to create tag' };\n  }\n}\n\nexport async function updateTag(id: string, name: string, color: string): Promise<{ success?: boolean; error?: string }> {\n  if (!id || !name.trim()) {\n    return { error: 'Invalid tag data' };\n  }\n\n  try {\n    await pool.query(\n      'UPDATE tags SET name = $1, color = $2 WHERE id = $3',\n      [name.trim().toLowerCase(), color, id]\n    );\n    return { success: true };\n  } catch (e: any) {\n    if (e.code === '23505') {\n      return { error: 'Tag name already exists' };\n    }\n    console.error(\"Failed to update tag:\", e);\n    return { error: 'Failed to update tag' };\n  }\n}\n\nexport async function deleteTag(id: string, tagName: string): Promise<{ success?: boolean; error?: string }> {\n  if (!id) {\n    return { error: 'Invalid tag ID' };\n  }\n\n  try {\n    // Delete the tag from the tags table\n    await pool.query('DELETE FROM tags WHERE id = $1', [id]);\n\n    // Remove this tag from all notes that use it\n    const notesResult = await pool.query('SELECT id, data FROM notes');\n    for (const row of notesResult.rows) {\n      const note = row.data as Note;\n      if (note.tags && note.tags.includes(tagName)) {\n        const updatedTags = note.tags.filter(t => t !== tagName);\n        const updatedNote = { ...note, tags: updatedTags };\n        await pool.query(\n          'UPDATE notes SET data = $1 WHERE id = $2',\n          [JSON.stringify(updatedNote), note.id]\n        );\n      }\n    }\n\n    return { success: true };\n  } catch (e) {\n    console.error(\"Failed to delete tag:\", e);\n    return { error: 'Failed to delete tag' };\n  }\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 672, "column": 0}, "map": {"version":3,"sources":["file:///D:/ANALISE%20DE%20DADOS/notations/.next-internal/server/app/admin/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {getTags as '00a27361b0caf8eef52e679cc4febeb0dfd20c4e0e'} from 'ACTIONS_MODULE0'\nexport {createTag as '6041cd847ee719e7a0e25a948ee66183b2ceb07cb1'} from 'ACTIONS_MODULE0'\nexport {updateTag as '7091c2d1bc383dc801598a0e074a6e2170cb10531b'} from 'ACTIONS_MODULE0'\nexport {deleteTag as '609dd24123ceaaf7918c2df81e340c49a02c357c50'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA"}}]
}