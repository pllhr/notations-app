{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///D:/ROCKETSEAT%20UPAR%20DROPBOX/ANALISE%20DE%20DADOS/notations/auth.config.ts"],"sourcesContent":["import type { NextAuthConfig } from 'next-auth';\r\n\r\nexport const authConfig = {\r\n    pages: {\r\n        signIn: '/login',\r\n    },\r\n    callbacks: {\r\n        authorized({ auth, request: { nextUrl } }) {\r\n            const isLoggedIn = !!auth?.user;\r\n\r\n            // Define public routes that don't require authentication\r\n            const publicRoutes = ['/login', '/register'];\r\n            const isOnPublicRoute = publicRoutes.some(route => nextUrl.pathname.startsWith(route));\r\n\r\n            if (isOnPublicRoute) {\r\n                if (isLoggedIn) {\r\n                    // Redirect logged-in users to home if they try to access login/register\r\n                    return Response.redirect(new URL('/', nextUrl));\r\n                }\r\n                return true;\r\n            }\r\n\r\n            // Protect all other routes\r\n            if (!isLoggedIn) {\r\n                return false; // Redirects to signIn page\r\n            }\r\n\r\n            return true;\r\n        },\r\n    },\r\n    providers: [], // Add providers with an empty array for now\r\n} satisfies NextAuthConfig;\r\n"],"names":[],"mappings":";;;;AAEO,MAAM,aAAa;IACtB,OAAO;QACH,QAAQ;IACZ;IACA,WAAW;QACP,YAAW,EAAE,IAAI,EAAE,SAAS,EAAE,OAAO,EAAE,EAAE;YACrC,MAAM,aAAa,CAAC,CAAC,MAAM;YAE3B,yDAAyD;YACzD,MAAM,eAAe;gBAAC;gBAAU;aAAY;YAC5C,MAAM,kBAAkB,aAAa,IAAI,CAAC,CAAA,QAAS,QAAQ,QAAQ,CAAC,UAAU,CAAC;YAE/E,IAAI,iBAAiB;gBACjB,IAAI,YAAY;oBACZ,wEAAwE;oBACxE,OAAO,SAAS,QAAQ,CAAC,IAAI,IAAI,KAAK;gBAC1C;gBACA,OAAO;YACX;YAEA,2BAA2B;YAC3B,IAAI,CAAC,YAAY;gBACb,OAAO,OAAO,2BAA2B;YAC7C;YAEA,OAAO;QACX;IACJ;IACA,WAAW,EAAE;AACjB"}},
    {"offset": {"line": 95, "column": 0}, "map": {"version":3,"sources":["file:///D:/ROCKETSEAT%20UPAR%20DROPBOX/ANALISE%20DE%20DADOS/notations/lib/db.ts"],"sourcesContent":["import { Pool } from '@neondatabase/serverless';\n\n// Prevent multiple connections in dev mode\nconst globalForDb = globalThis as unknown as {\n    conn: Pool | undefined;\n};\n\nconst pool = globalForDb.conn ?? new Pool({ connectionString: process.env.DATABASE_URL });\n\nif (process.env.NODE_ENV !== 'production') globalForDb.conn = pool;\n\nexport default pool;"],"names":[],"mappings":";;;;AAAA;;AAEA,2CAA2C;AAC3C,MAAM,cAAc;AAIpB,MAAM,OAAO,YAAY,IAAI,IAAI,IAAI,gKAAI,CAAC;IAAE,kBAAkB,QAAQ,GAAG,CAAC,YAAY;AAAC;AAEvF,wCAA2C,YAAY,IAAI,GAAG;uCAE/C"}},
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///D:/ROCKETSEAT%20UPAR%20DROPBOX/ANALISE%20DE%20DADOS/notations/lib/data.ts"],"sourcesContent":["import pool from './db';\r\nimport { User } from '../types';\r\n\r\nexport async function getUserByEmail(email: string): Promise<User & { password_hash: string } | null> {\r\n    try {\r\n        const result = await pool.query('SELECT * FROM users WHERE email = $1', [email]);\r\n        return result.rows[0] || null;\r\n    } catch (error) {\r\n        console.error('Failed to fetch user:', error);\r\n        throw new Error('Failed to fetch user.');\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;;AAGO,eAAe,eAAe,KAAa;IAC9C,IAAI;QACA,MAAM,SAAS,MAAM,sHAAI,CAAC,KAAK,CAAC,wCAAwC;YAAC;SAAM;QAC/E,OAAO,OAAO,IAAI,CAAC,EAAE,IAAI;IAC7B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,yBAAyB;QACvC,MAAM,IAAI,MAAM;IACpB;AACJ"}},
    {"offset": {"line": 133, "column": 0}, "map": {"version":3,"sources":["file:///D:/ROCKETSEAT%20UPAR%20DROPBOX/ANALISE%20DE%20DADOS/notations/auth.ts"],"sourcesContent":["import NextAuth from 'next-auth';\r\nimport Credentials from 'next-auth/providers/credentials';\r\nimport { z } from 'zod';\r\nimport bcrypt from 'bcryptjs';\r\nimport { authConfig } from './auth.config';\r\nimport { getUserByEmail } from './lib/data';\r\n\r\nexport const { auth, signIn, signOut, handlers } = NextAuth({\r\n    ...authConfig,\r\n    callbacks: {\r\n        ...authConfig.callbacks,\r\n        async session({ session, token }) {\r\n            if (token.sub && session.user) {\r\n                session.user.id = token.sub;\r\n            }\r\n            if (token.role && session.user) {\r\n                session.user.role = token.role as 'USER' | 'ADMIN';\r\n            }\r\n            if (token.createdAt && session.user) {\r\n                session.user.createdAt = token.createdAt as number;\r\n            }\r\n            if (token.name && session.user) {\r\n                session.user.name = token.name;\r\n            }\r\n            // Image is NOT stored in session anymore to prevent header overflow\r\n            return session;\r\n        },\r\n        async jwt({ token, user, trigger, session }) {\r\n            if (user) {\r\n                token.role = (user as any).role;\r\n                token.createdAt = (user as any).created_at;\r\n                token.name = user.name;\r\n                // token.image is intentionally omitted\r\n            }\r\n\r\n            // Update token if session is updated (e.g. name change)\r\n            if (trigger === \"update\" && session) {\r\n                token.name = session.user.name;\r\n            }\r\n\r\n            return token;\r\n        },\r\n    },\r\n    providers: [\r\n        Credentials({\r\n            async authorize(credentials) {\r\n                const parsedCredentials = z\r\n                    .object({ email: z.string().email(), password: z.string().min(6) })\r\n                    .safeParse(credentials);\r\n\r\n                if (parsedCredentials.success) {\r\n                    const { email, password } = parsedCredentials.data;\r\n                    const user = await getUserByEmail(email);\r\n                    if (!user) return null;\r\n\r\n                    const passwordsMatch = await bcrypt.compare(password, user.password_hash);\r\n                    if (passwordsMatch) return user;\r\n                }\r\n\r\n                console.log('Invalid credentials');\r\n                return null;\r\n            },\r\n        }),\r\n    ],\r\n});\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;AAEO,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,GAAG,IAAA,kKAAQ,EAAC;IACxD,GAAG,8HAAU;IACb,WAAW;QACP,GAAG,8HAAU,CAAC,SAAS;QACvB,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC5B,IAAI,MAAM,GAAG,IAAI,QAAQ,IAAI,EAAE;gBAC3B,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,GAAG;YAC/B;YACA,IAAI,MAAM,IAAI,IAAI,QAAQ,IAAI,EAAE;gBAC5B,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YAClC;YACA,IAAI,MAAM,SAAS,IAAI,QAAQ,IAAI,EAAE;gBACjC,QAAQ,IAAI,CAAC,SAAS,GAAG,MAAM,SAAS;YAC5C;YACA,IAAI,MAAM,IAAI,IAAI,QAAQ,IAAI,EAAE;gBAC5B,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YAClC;YACA,oEAAoE;YACpE,OAAO;QACX;QACA,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE;YACvC,IAAI,MAAM;gBACN,MAAM,IAAI,GAAG,AAAC,KAAa,IAAI;gBAC/B,MAAM,SAAS,GAAG,AAAC,KAAa,UAAU;gBAC1C,MAAM,IAAI,GAAG,KAAK,IAAI;YACtB,uCAAuC;YAC3C;YAEA,wDAAwD;YACxD,IAAI,YAAY,YAAY,SAAS;gBACjC,MAAM,IAAI,GAAG,QAAQ,IAAI,CAAC,IAAI;YAClC;YAEA,OAAO;QACX;IACJ;IACA,WAAW;QACP,IAAA,uKAAW,EAAC;YACR,MAAM,WAAU,WAAW;gBACvB,MAAM,oBAAoB,yKAAC,CACtB,MAAM,CAAC;oBAAE,OAAO,yKAAC,CAAC,MAAM,GAAG,KAAK;oBAAI,UAAU,yKAAC,CAAC,MAAM,GAAG,GAAG,CAAC;gBAAG,GAChE,SAAS,CAAC;gBAEf,IAAI,kBAAkB,OAAO,EAAE;oBAC3B,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,kBAAkB,IAAI;oBAClD,MAAM,OAAO,MAAM,IAAA,+HAAc,EAAC;oBAClC,IAAI,CAAC,MAAM,OAAO;oBAElB,MAAM,iBAAiB,MAAM,8IAAM,CAAC,OAAO,CAAC,UAAU,KAAK,aAAa;oBACxE,IAAI,gBAAgB,OAAO;gBAC/B;gBAEA,QAAQ,GAAG,CAAC;gBACZ,OAAO;YACX;QACJ;KACH;AACL"}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":["file:///D:/ROCKETSEAT%20UPAR%20DROPBOX/ANALISE%20DE%20DADOS/notations/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import { handlers } from \"../../../../auth\"; // Adjust path based on where auth.ts is\r\nexport const { GET, POST } = handlers;\r\n"],"names":[],"mappings":";;;;;;AAAA,oLAA6C,wCAAwC;;AAC9E,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,kHAAQ"}}]
}